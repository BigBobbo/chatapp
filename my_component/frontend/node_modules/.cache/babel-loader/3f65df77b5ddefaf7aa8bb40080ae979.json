{"ast":null,"code":"import { Streamlit } from \"streamlit-component-lib\";\nimport * as SpeechSDK from 'microsoft-cognitiveservices-speech-sdk';\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\nconst span = document.body.appendChild(document.createElement(\"span\"));\nconst textNode = span.appendChild(document.createTextNode(\"\"));\nconst button = span.appendChild(document.createElement(\"button\"));\nbutton.textContent = \"Click Me!\";\n\n// Add a click handler to our button. It will send data back to Streamlit.\n\n// let numClicks = {}\nlet isFocused = false;\nbutton.onclick = function () {\n  // Increment numClicks, and pass the new value back to\n  // Streamlit via `Streamlit.setComponentValue`.\n  var speechConfig = SpeechSDK.SpeechConfig.fromSubscription('2f322ae248fe4d758305ef1827d67b0a', 'eastus');\n  speechConfig.speechRecognitionLanguage = \"en-US\";\n  var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();\n  var recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);\n  recognizer.recognizeOnceAsync(function (result) {\n    // startRecognizeOnceAsyncButton.disabled = false;\n    // phraseDiv.innerHTML += result.text;\n    window.console.log(result);\n    recognizer.close();\n    Streamlit.setComponentValue(result);\n    // recognizer = undefined;\n  }, function (err) {\n    // startRecognizeOnceAsyncButton.disabled = false;\n    // phraseDiv.innerHTML += err;\n    window.console.log(err);\n    recognizer.close();\n    // recognizer = undefined;\n  });\n\n  // numClicks += 1\n  // Streamlit.setComponentValue(numClicks) \n};\n\nbutton.onfocus = function () {\n  isFocused = true;\n};\nbutton.onblur = function () {\n  isFocused = false;\n};\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event) {\n  // Get the RenderData from the event\n  const data = event.detail;\n\n  // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  if (data.theme) {\n    // Use CSS vars to style our button border. Alternatively, the theme style\n    // is defined in the data.theme object.\n    const borderStyling = `1px solid var(${isFocused ? \"--primary-color\" : \"gray\"})`;\n    button.style.border = borderStyling;\n    button.style.outline = borderStyling;\n  }\n\n  // Disable our button if necessary.\n  button.disabled = data.disabled;\n\n  // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n  let name = data.args[\"name\"];\n\n  // Show \"Hello, name!\" with a non-breaking space afterwards.\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160);\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight();\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender);\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady();\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight();","map":{"version":3,"names":["Streamlit","SpeechSDK","span","document","body","appendChild","createElement","textNode","createTextNode","button","textContent","isFocused","onclick","speechConfig","SpeechConfig","fromSubscription","speechRecognitionLanguage","audioConfig","AudioConfig","fromDefaultMicrophoneInput","recognizer","SpeechRecognizer","recognizeOnceAsync","result","window","console","log","close","setComponentValue","err","onfocus","onblur","onRender","event","data","detail","theme","borderStyling","style","border","outline","disabled","name","args","String","fromCharCode","setFrameHeight","events","addEventListener","RENDER_EVENT","setComponentReady"],"sources":["/Users/robertocallaghan/Documents/gailge/javascript/component-template/template-reactless/my_component/frontend/src/index.tsx"],"sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\nimport * as SpeechSDK from 'microsoft-cognitiveservices-speech-sdk';\n\n\n// Add text and a button to the DOM. (You could also add these directly\n// to index.html.)\nconst span = document.body.appendChild(document.createElement(\"span\"))\nconst textNode = span.appendChild(document.createTextNode(\"\"))\nconst button = span.appendChild(document.createElement(\"button\"))\nbutton.textContent = \"Click Me!\"\n\n// Add a click handler to our button. It will send data back to Streamlit.\n\n// let numClicks = {}\nlet isFocused = false\nbutton.onclick = function(): void {\n  // Increment numClicks, and pass the new value back to\n  // Streamlit via `Streamlit.setComponentValue`.\n        var speechConfig = SpeechSDK.SpeechConfig.fromSubscription('2f322ae248fe4d758305ef1827d67b0a', 'eastus');\n        speechConfig.speechRecognitionLanguage = \"en-US\";\n        var audioConfig  = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();\n        var recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);\n\n        recognizer.recognizeOnceAsync(\n          function (result) {\n            // startRecognizeOnceAsyncButton.disabled = false;\n            // phraseDiv.innerHTML += result.text;\n            window.console.log(result);\n            recognizer.close();\n            Streamlit.setComponentValue(result) \n            // recognizer = undefined;\n          },\n          function (err) {\n            // startRecognizeOnceAsyncButton.disabled = false;\n            // phraseDiv.innerHTML += err;\n            window.console.log(err);\n\n            recognizer.close();\n            // recognizer = undefined;\n          }); \n\n\n\n  // numClicks += 1\n  // Streamlit.setComponentValue(numClicks) \n}\n\nbutton.onfocus = function(): void {\n  isFocused = true\n}\n\nbutton.onblur = function(): void {\n  isFocused = false\n}\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  if (data.theme) {\n    // Use CSS vars to style our button border. Alternatively, the theme style\n    // is defined in the data.theme object.\n    const borderStyling = `1px solid var(${\n      isFocused ? \"--primary-color\" : \"gray\"\n    })`\n    button.style.border = borderStyling\n    button.style.outline = borderStyling\n  }\n\n  // Disable our button if necessary.\n  button.disabled = data.disabled\n\n  // RenderData.args is the JSON dictionary of arguments sent from the\n  // Python script.\n  let name = data.args[\"name\"]\n\n  // Show \"Hello, name!\" with a non-breaking space afterwards.\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"mappings":"AAAA,SAASA,SAAS,QAAoB,yBAAyB;AAC/D,OAAO,KAAKC,SAAS,MAAM,wCAAwC;;AAGnE;AACA;AACA,MAAMC,IAAI,GAAGC,QAAQ,CAACC,IAAI,CAACC,WAAW,CAACF,QAAQ,CAACG,aAAa,CAAC,MAAM,CAAC,CAAC;AACtE,MAAMC,QAAQ,GAAGL,IAAI,CAACG,WAAW,CAACF,QAAQ,CAACK,cAAc,CAAC,EAAE,CAAC,CAAC;AAC9D,MAAMC,MAAM,GAAGP,IAAI,CAACG,WAAW,CAACF,QAAQ,CAACG,aAAa,CAAC,QAAQ,CAAC,CAAC;AACjEG,MAAM,CAACC,WAAW,GAAG,WAAW;;AAEhC;;AAEA;AACA,IAAIC,SAAS,GAAG,KAAK;AACrBF,MAAM,CAACG,OAAO,GAAG,YAAiB;EAChC;EACA;EACM,IAAIC,YAAY,GAAGZ,SAAS,CAACa,YAAY,CAACC,gBAAgB,CAAC,kCAAkC,EAAE,QAAQ,CAAC;EACxGF,YAAY,CAACG,yBAAyB,GAAG,OAAO;EAChD,IAAIC,WAAW,GAAIhB,SAAS,CAACiB,WAAW,CAACC,0BAA0B,EAAE;EACrE,IAAIC,UAAU,GAAG,IAAInB,SAAS,CAACoB,gBAAgB,CAACR,YAAY,EAAEI,WAAW,CAAC;EAE1EG,UAAU,CAACE,kBAAkB,CAC3B,UAAUC,MAAM,EAAE;IAChB;IACA;IACAC,MAAM,CAACC,OAAO,CAACC,GAAG,CAACH,MAAM,CAAC;IAC1BH,UAAU,CAACO,KAAK,EAAE;IAClB3B,SAAS,CAAC4B,iBAAiB,CAACL,MAAM,CAAC;IACnC;EACF,CAAC,EACD,UAAUM,GAAG,EAAE;IACb;IACA;IACAL,MAAM,CAACC,OAAO,CAACC,GAAG,CAACG,GAAG,CAAC;IAEvBT,UAAU,CAACO,KAAK,EAAE;IAClB;EACF,CAAC,CAAC;;EAIV;EACA;AACF,CAAC;;AAEDlB,MAAM,CAACqB,OAAO,GAAG,YAAiB;EAChCnB,SAAS,GAAG,IAAI;AAClB,CAAC;AAEDF,MAAM,CAACsB,MAAM,GAAG,YAAiB;EAC/BpB,SAAS,GAAG,KAAK;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASqB,QAAQ,CAACC,KAAY,EAAQ;EACpC;EACA,MAAMC,IAAI,GAAID,KAAK,CAA6BE,MAAM;;EAEtD;EACA;EACA,IAAID,IAAI,CAACE,KAAK,EAAE;IACd;IACA;IACA,MAAMC,aAAa,GAAI,iBACrB1B,SAAS,GAAG,iBAAiB,GAAG,MACjC,GAAE;IACHF,MAAM,CAAC6B,KAAK,CAACC,MAAM,GAAGF,aAAa;IACnC5B,MAAM,CAAC6B,KAAK,CAACE,OAAO,GAAGH,aAAa;EACtC;;EAEA;EACA5B,MAAM,CAACgC,QAAQ,GAAGP,IAAI,CAACO,QAAQ;;EAE/B;EACA;EACA,IAAIC,IAAI,GAAGR,IAAI,CAACS,IAAI,CAAC,MAAM,CAAC;;EAE5B;EACApC,QAAQ,CAACG,WAAW,GAAI,UAASgC,IAAK,IAAG,GAAGE,MAAM,CAACC,YAAY,CAAC,GAAG,CAAC;;EAEpE;EACA;EACA;EACA;EACA7C,SAAS,CAAC8C,cAAc,EAAE;AAC5B;;AAEA;AACA9C,SAAS,CAAC+C,MAAM,CAACC,gBAAgB,CAAChD,SAAS,CAACiD,YAAY,EAAEjB,QAAQ,CAAC;;AAEnE;AACA;AACAhC,SAAS,CAACkD,iBAAiB,EAAE;;AAE7B;AACA;AACAlD,SAAS,CAAC8C,cAAc,EAAE"},"metadata":{},"sourceType":"module"}