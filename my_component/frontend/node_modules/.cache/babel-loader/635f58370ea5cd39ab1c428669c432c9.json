{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n/* eslint-disable max-classes-per-file */\nimport { AudioSourceErrorEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ConnectionEstablishedEvent, ConnectionEstablishErrorEvent, ConnectionMessageReceivedEvent, ConnectionStartEvent } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nexport class ServiceTelemetryListener {\n  constructor(requestId, audioSourceId, audioNodeId) {\n    this.privIsDisposed = false;\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privRequestId = requestId;\n    this.privAudioSourceId = audioSourceId;\n    this.privAudioNodeId = audioNodeId;\n    this.privReceivedMessages = {};\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n  }\n  phraseReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n  hypothesisReceived(audioReceivedTime) {\n    if (audioReceivedTime > 0) {\n      // 0 indicates the time is unknown. Drop it.\n      this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\n    }\n  }\n  onEvent(e) {\n    if (this.privIsDisposed) {\n      return;\n    }\n    if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\n      this.privListeningTriggerMetric = {\n        End: e.eventTime,\n        Name: \"ListeningTrigger\",\n        Start: e.eventTime\n      };\n    }\n    if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n    if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      this.privMicStartTime = e.eventTime;\n    }\n    if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Error: e.error,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\n      if (!this.privMicMetric) {\n        this.privMicMetric = {\n          End: e.eventTime,\n          Name: \"Microphone\",\n          Start: this.privMicStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\n      this.privConnectionId = e.sessionId;\n    }\n    if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\n      this.privConnectionStartTime = e.eventTime;\n    }\n    if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\n      if (!this.privConnectionEstablishMetric) {\n        this.privConnectionEstablishMetric = {\n          End: e.eventTime,\n          Error: this.getConnectionError(e.statusCode),\n          Id: this.privConnectionId,\n          Name: \"Connection\",\n          Start: this.privConnectionStartTime\n        };\n      }\n    }\n    if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\n      if (e.message && e.message.headers && e.message.headers.path) {\n        if (!this.privReceivedMessages[e.message.headers.path]) {\n          this.privReceivedMessages[e.message.headers.path] = new Array();\n        }\n        const maxMessagesToSend = 50;\n        if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\n          this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\n        }\n      }\n    }\n  }\n  getTelemetry() {\n    const metrics = new Array();\n    if (this.privListeningTriggerMetric) {\n      metrics.push(this.privListeningTriggerMetric);\n    }\n    if (this.privMicMetric) {\n      metrics.push(this.privMicMetric);\n    }\n    if (this.privConnectionEstablishMetric) {\n      metrics.push(this.privConnectionEstablishMetric);\n    }\n    if (this.privPhraseLatencies.length > 0) {\n      metrics.push({\n        PhraseLatencyMs: this.privPhraseLatencies\n      });\n    }\n    if (this.privHypothesisLatencies.length > 0) {\n      metrics.push({\n        FirstHypothesisLatencyMs: this.privHypothesisLatencies\n      });\n    }\n    const telemetry = {\n      Metrics: metrics,\n      ReceivedMessages: this.privReceivedMessages\n    };\n    const json = JSON.stringify(telemetry);\n    // We dont want to send the same telemetry again. So clean those out.\n    this.privReceivedMessages = {};\n    this.privListeningTriggerMetric = null;\n    this.privMicMetric = null;\n    this.privConnectionEstablishMetric = null;\n    this.privPhraseLatencies = [];\n    this.privHypothesisLatencies = [];\n    return json;\n  }\n  // Determines if there are any telemetry events to send to the service.\n  get hasTelemetry() {\n    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;\n  }\n  dispose() {\n    this.privIsDisposed = true;\n  }\n  getConnectionError(statusCode) {\n    /*\n    -- Websocket status codes --\n    NormalClosure = 1000,\n    EndpointUnavailable = 1001,\n    ProtocolError = 1002,\n    InvalidMessageType = 1003,\n    Empty = 1005,\n    InvalidPayloadData = 1007,\n    PolicyViolation = 1008,\n    MessageTooBig = 1009,\n    MandatoryExtension = 1010,\n    InternalServerError = 1011\n    */\n    switch (statusCode) {\n      case 400:\n      case 1002:\n      case 1003:\n      case 1005:\n      case 1007:\n      case 1008:\n      case 1009:\n        return \"BadRequest\";\n      case 401:\n        return \"Unauthorized\";\n      case 403:\n        return \"Forbidden\";\n      case 503:\n      case 1001:\n        return \"ServerUnavailable\";\n      case 500:\n      case 1011:\n        return \"ServerError\";\n      case 408:\n      case 504:\n        return \"Timeout\";\n      default:\n        return \"statuscode:\" + statusCode.toString();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["AudioSourceErrorEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ConnectionEstablishedEvent","ConnectionEstablishErrorEvent","ConnectionMessageReceivedEvent","ConnectionStartEvent","ConnectingToServiceEvent","RecognitionTriggeredEvent","ServiceTelemetryListener","constructor","requestId","audioSourceId","audioNodeId","privRequestId","privAudioSourceId","privAudioNodeId","privReceivedMessages","privPhraseLatencies","privHypothesisLatencies","phraseReceived","audioReceivedTime","push","Date","now","hypothesisReceived","onEvent","e","privIsDisposed","privListeningTriggerMetric","End","eventTime","Name","Start","privMicStartTime","privMicMetric","Error","error","privConnectionId","sessionId","connectionId","privConnectionStartTime","privConnectionEstablishMetric","Id","getConnectionError","statusCode","message","headers","path","Array","maxMessagesToSend","length","networkReceivedTime","getTelemetry","metrics","PhraseLatencyMs","FirstHypothesisLatencyMs","telemetry","Metrics","ReceivedMessages","json","JSON","stringify","hasTelemetry","Object","keys","dispose","toString"],"sources":["src/common.speech/ServiceTelemetryListener.Internal.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n/* eslint-disable max-classes-per-file */\r\n\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEstablishErrorEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionStartEvent,\r\n    IEventListener,\r\n    IStringDictionary,\r\n    PlatformEvent,\r\n} from \"../common/Exports\";\r\nimport { ConnectingToServiceEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\r\n\r\nexport interface ITelemetry {\r\n    Metrics: IMetric[];\r\n    ReceivedMessages: IStringDictionary<string[]>;\r\n}\r\n\r\nexport interface IMetric {\r\n    End?: string;\r\n    Error?: string;\r\n    Id?: string;\r\n    Name?: string;\r\n    Start?: string;\r\n    PhraseLatencyMs?: number[];\r\n    FirstHypothesisLatencyMs?: number[];\r\n}\r\n\r\nexport class ServiceTelemetryListener implements IEventListener<PlatformEvent> {\r\n    private privIsDisposed: boolean = false;\r\n\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n\r\n    private privListeningTriggerMetric: IMetric = null;\r\n    private privMicMetric: IMetric = null;\r\n    private privConnectionEstablishMetric: IMetric = null;\r\n\r\n    private privMicStartTime: string;\r\n\r\n    private privConnectionId: string;\r\n    private privConnectionStartTime: string;\r\n\r\n    private privReceivedMessages: IStringDictionary<string[]>;\r\n    private privPhraseLatencies: number[];\r\n    private privHypothesisLatencies: number[];\r\n\r\n    public constructor(requestId: string, audioSourceId: string, audioNodeId: string) {\r\n        this.privRequestId = requestId;\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privAudioNodeId = audioNodeId;\r\n\r\n        this.privReceivedMessages = {};\r\n        this.privPhraseLatencies = [];\r\n        this.privHypothesisLatencies = [];\r\n    }\r\n\r\n    public phraseReceived(audioReceivedTime: number): void {\r\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\r\n            this.privPhraseLatencies.push(Date.now() - audioReceivedTime);\r\n        }\r\n    }\r\n\r\n    public hypothesisReceived(audioReceivedTime: number): void {\r\n        if (audioReceivedTime > 0) { // 0 indicates the time is unknown. Drop it.\r\n            this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);\r\n        }\r\n    }\r\n\r\n    public onEvent(e: PlatformEvent): void {\r\n        if (this.privIsDisposed) {\r\n            return;\r\n        }\r\n\r\n        if (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId) {\r\n            this.privListeningTriggerMetric = {\r\n                End: e.eventTime,\r\n                Name: \"ListeningTrigger\",\r\n                Start: e.eventTime,\r\n            };\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            this.privMicStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            this.privMicStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Error: e.error,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Error: e.error,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {\r\n            if (!this.privMicMetric) {\r\n                this.privMicMetric = {\r\n                    End: e.eventTime,\r\n                    Name: \"Microphone\",\r\n                    Start: this.privMicStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId) {\r\n            this.privConnectionId = e.sessionId;\r\n        }\r\n\r\n        if (e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId) {\r\n            this.privConnectionStartTime = e.eventTime;\r\n        }\r\n\r\n        if (e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {\r\n            if (!this.privConnectionEstablishMetric) {\r\n                this.privConnectionEstablishMetric = {\r\n                    End: e.eventTime,\r\n                    Id: this.privConnectionId,\r\n                    Name: \"Connection\",\r\n                    Start: this.privConnectionStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {\r\n            if (!this.privConnectionEstablishMetric) {\r\n                this.privConnectionEstablishMetric = {\r\n                    End: e.eventTime,\r\n                    Error: this.getConnectionError(e.statusCode),\r\n                    Id: this.privConnectionId,\r\n                    Name: \"Connection\",\r\n                    Start: this.privConnectionStartTime,\r\n                };\r\n            }\r\n        }\r\n\r\n        if (e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {\r\n            if (e.message && e.message.headers && e.message.headers.path) {\r\n                if (!this.privReceivedMessages[e.message.headers.path]) {\r\n                    this.privReceivedMessages[e.message.headers.path] = new Array<string>();\r\n                }\r\n                const maxMessagesToSend = 50;\r\n                if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {\r\n                    this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public getTelemetry(): string {\r\n        const metrics = new Array<IMetric>();\r\n\r\n        if (this.privListeningTriggerMetric) {\r\n            metrics.push(this.privListeningTriggerMetric);\r\n        }\r\n\r\n        if (this.privMicMetric) {\r\n            metrics.push(this.privMicMetric);\r\n        }\r\n\r\n        if (this.privConnectionEstablishMetric) {\r\n            metrics.push(this.privConnectionEstablishMetric);\r\n        }\r\n\r\n        if (this.privPhraseLatencies.length > 0) {\r\n            metrics.push({\r\n                PhraseLatencyMs: this.privPhraseLatencies,\r\n            });\r\n        }\r\n\r\n        if (this.privHypothesisLatencies.length > 0) {\r\n            metrics.push({\r\n                FirstHypothesisLatencyMs: this.privHypothesisLatencies,\r\n            });\r\n        }\r\n\r\n        const telemetry: ITelemetry = {\r\n            Metrics: metrics,\r\n            ReceivedMessages: this.privReceivedMessages,\r\n        };\r\n\r\n        const json = JSON.stringify(telemetry);\r\n\r\n        // We dont want to send the same telemetry again. So clean those out.\r\n        this.privReceivedMessages = {};\r\n        this.privListeningTriggerMetric = null;\r\n        this.privMicMetric = null;\r\n        this.privConnectionEstablishMetric = null;\r\n        this.privPhraseLatencies = [];\r\n        this.privHypothesisLatencies = [];\r\n        return json;\r\n    }\r\n\r\n    // Determines if there are any telemetry events to send to the service.\r\n    public get hasTelemetry(): boolean {\r\n        return (Object.keys(this.privReceivedMessages).length !== 0 ||\r\n            this.privListeningTriggerMetric !== null ||\r\n            this.privMicMetric !== null ||\r\n            this.privConnectionEstablishMetric !== null ||\r\n            this.privPhraseLatencies.length !== 0 ||\r\n            this.privHypothesisLatencies.length !== 0);\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.privIsDisposed = true;\r\n    }\r\n\r\n    private getConnectionError(statusCode: number): string {\r\n        /*\r\n        -- Websocket status codes --\r\n        NormalClosure = 1000,\r\n        EndpointUnavailable = 1001,\r\n        ProtocolError = 1002,\r\n        InvalidMessageType = 1003,\r\n        Empty = 1005,\r\n        InvalidPayloadData = 1007,\r\n        PolicyViolation = 1008,\r\n        MessageTooBig = 1009,\r\n        MandatoryExtension = 1010,\r\n        InternalServerError = 1011\r\n        */\r\n\r\n        switch (statusCode) {\r\n            case 400:\r\n            case 1002:\r\n            case 1003:\r\n            case 1005:\r\n            case 1007:\r\n            case 1008:\r\n            case 1009: return \"BadRequest\";\r\n            case 401: return \"Unauthorized\";\r\n            case 403: return \"Forbidden\";\r\n            case 503:\r\n            case 1001: return \"ServerUnavailable\";\r\n            case 500:\r\n            case 1011: return \"ServerError\";\r\n            case 408:\r\n            case 504: return \"Timeout\";\r\n            default: return \"statuscode:\" + statusCode.toString();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}