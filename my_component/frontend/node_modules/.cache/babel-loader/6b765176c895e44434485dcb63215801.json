{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n// Node.JS specific web socket / browser support.\nimport ws from \"ws\";\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { ArgumentNullError, BackgroundEvent, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, Queue, RawWebsocketMessage } from \"../common/Exports\";\nimport { CertCheckAgent } from \"./CertChecks\";\nexport class WebsocketMessageAdapter {\n  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n    if (!uri) {\n      throw new ArgumentNullError(\"uri\");\n    }\n    if (!messageFormatter) {\n      throw new ArgumentNullError(\"messageFormatter\");\n    }\n    this.proxyInfo = proxyInfo;\n    this.privConnectionEvents = new EventSource();\n    this.privConnectionId = connectionId;\n    this.privMessageFormatter = messageFormatter;\n    this.privConnectionState = ConnectionState.None;\n    this.privUri = uri;\n    this.privHeaders = headers;\n    this.privEnableCompression = enableCompression;\n    // Add the connection ID to the headers\n    this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\n    this.privLastErrorReceived = \"\";\n  }\n  get state() {\n    return this.privConnectionState;\n  }\n  open() {\n    if (this.privConnectionState === ConnectionState.Disconnected) {\n      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n    }\n    if (this.privConnectionEstablishDeferral) {\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.privConnectionEstablishDeferral = new Deferred();\n    this.privCertificateValidatedDeferral = new Deferred();\n    this.privConnectionState = ConnectionState.Connecting;\n    try {\n      if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n        // Browser handles cert checks.\n        this.privCertificateValidatedDeferral.resolve();\n        this.privWebsocketClient = new WebSocket(this.privUri);\n      } else {\n        const options = {\n          headers: this.privHeaders,\n          perMessageDeflate: this.privEnableCompression\n        };\n        // The ocsp library will handle validation for us and fail the connection if needed.\n        this.privCertificateValidatedDeferral.resolve();\n        const checkAgent = new CertCheckAgent(this.proxyInfo);\n        options.agent = checkAgent.GetAgent();\n        // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\n        // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\n        const uri = new URL(this.privUri);\n        let protocol = uri.protocol;\n        if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"wss:\") {\n          protocol = \"https:\";\n        } else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"ws:\") {\n          protocol = \"http:\";\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        options.agent.protocol = protocol;\n        this.privWebsocketClient = new ws(this.privUri, options);\n      }\n      this.privWebsocketClient.binaryType = \"arraybuffer\";\n      this.privReceivingMessageQueue = new Queue();\n      this.privDisconnectDeferral = new Deferred();\n      this.privSendMessageQueue = new Queue();\n      this.processSendQueue().catch(reason => {\n        Events.instance.onEvent(new BackgroundEvent(reason));\n      });\n    } catch (error) {\n      this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n      return this.privConnectionEstablishDeferral.promise;\n    }\n    this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n    this.privWebsocketClient.onopen = () => {\n      this.privCertificateValidatedDeferral.promise.then(() => {\n        this.privConnectionState = ConnectionState.Connected;\n        this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n      }, error => {\n        this.privConnectionEstablishDeferral.reject(error);\n      });\n    };\n    this.privWebsocketClient.onerror = e => {\n      this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n      this.privLastErrorReceived = e.message;\n    };\n    this.privWebsocketClient.onclose = e => {\n      if (this.privConnectionState === ConnectionState.Connecting) {\n        this.privConnectionState = ConnectionState.Disconnected;\n        // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n      } else {\n        this.privConnectionState = ConnectionState.Disconnected;\n        this.privWebsocketClient = null;\n        this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n      }\n      this.onClose(e.code, e.reason).catch(reason => {\n        Events.instance.onEvent(new BackgroundEvent(reason));\n      });\n    };\n    this.privWebsocketClient.onmessage = e => {\n      const networkReceivedTime = new Date().toISOString();\n      if (this.privConnectionState === ConnectionState.Connected) {\n        const deferred = new Deferred();\n        // let id = ++this.idCounter;\n        this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n        if (e.data instanceof ArrayBuffer) {\n          const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid binary message format. Error: ${error}`);\n          });\n        } else {\n          const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n            deferred.resolve(connectionMessage);\n          }, error => {\n            // TODO: Events for these ?\n            deferred.reject(`Invalid text message format. Error: ${error}`);\n          });\n        }\n      }\n    };\n    return this.privConnectionEstablishDeferral.promise;\n  }\n  send(message) {\n    if (this.privConnectionState !== ConnectionState.Connected) {\n      return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\n    }\n    const messageSendStatusDeferral = new Deferred();\n    const messageSendDeferral = new Deferred();\n    this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n    this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {\n      messageSendDeferral.resolve({\n        Message: message,\n        RawWebsocketMessage: rawMessage,\n        sendStatusDeferral: messageSendStatusDeferral\n      });\n    }, error => {\n      messageSendDeferral.reject(`Error formatting the message. ${error}`);\n    });\n    return messageSendStatusDeferral.promise;\n  }\n  read() {\n    if (this.privConnectionState !== ConnectionState.Connected) {\n      return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n    }\n    return this.privReceivingMessageQueue.dequeue();\n  }\n  close(reason) {\n    if (this.privWebsocketClient) {\n      if (this.privConnectionState !== ConnectionState.Disconnected) {\n        this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n      }\n    } else {\n      return Promise.resolve();\n    }\n    return this.privDisconnectDeferral.promise;\n  }\n  get events() {\n    return this.privConnectionEvents;\n  }\n  sendRawMessage(sendItem) {\n    try {\n      // indicates we are draining the queue and it came with no message;\n      if (!sendItem) {\n        return Promise.resolve();\n      }\n      this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\n      // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n      if (this.isWebsocketOpen) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n      } else {\n        return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n      }\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(`websocket send error: ${e}`);\n    }\n  }\n  onClose(code, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const closeReason = `Connection closed. ${code}: ${reason}`;\n      this.privConnectionState = ConnectionState.Disconnected;\n      this.privDisconnectDeferral.resolve();\n      yield this.privReceivingMessageQueue.drainAndDispose(() => {\n        // TODO: Events for these ?\n        // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n      }, closeReason);\n      yield this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n        pendingSendItem.sendStatusDeferral.reject(closeReason);\n      }, closeReason);\n    });\n  }\n  processSendQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n      while (true) {\n        const itemToSend = this.privSendMessageQueue.dequeue();\n        const sendItem = yield itemToSend;\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return;\n        }\n        try {\n          yield this.sendRawMessage(sendItem);\n          sendItem.sendStatusDeferral.resolve();\n        } catch (sendError) {\n          sendItem.sendStatusDeferral.reject(sendError);\n        }\n      }\n    });\n  }\n  onEvent(event) {\n    this.privConnectionEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n  get isWebsocketOpen() {\n    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n  }\n}\nWebsocketMessageAdapter.forceNpmWebSocket = false;","map":{"version":3,"mappings":"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","names":["ws","HeaderNames","ArgumentNullError","BackgroundEvent","ConnectionClosedEvent","ConnectionErrorEvent","ConnectionEstablishedEvent","ConnectionMessageReceivedEvent","ConnectionMessageSentEvent","ConnectionOpenResponse","ConnectionStartEvent","ConnectionState","Deferred","Events","EventSource","MessageType","Queue","RawWebsocketMessage","CertCheckAgent","WebsocketMessageAdapter","constructor","uri","connectionId","messageFormatter","proxyInfo","headers","enableCompression","privConnectionEvents","privConnectionId","privMessageFormatter","privConnectionState","None","privUri","privHeaders","privEnableCompression","ConnectionId","privLastErrorReceived","state","open","Disconnected","Promise","reject","privConnectionEstablishDeferral","promise","privCertificateValidatedDeferral","Connecting","WebSocket","forceNpmWebSocket","resolve","privWebsocketClient","options","perMessageDeflate","checkAgent","agent","GetAgent","URL","protocol","toLocaleLowerCase","binaryType","privReceivingMessageQueue","privDisconnectDeferral","privSendMessageQueue","processSendQueue","catch","reason","instance","onEvent","error","onopen","then","Connected","onerror","e","message","type","onclose","code","onClose","onmessage","networkReceivedTime","Date","toISOString","deferred","enqueueFromPromise","data","ArrayBuffer","rawMessage","Binary","toConnectionMessage","connectionMessage","Text","send","messageSendStatusDeferral","messageSendDeferral","fromConnectionMessage","Message","sendStatusDeferral","read","dequeue","close","events","sendRawMessage","sendItem","isWebsocketOpen","payload","id","Error","stack","closeReason","drainAndDispose","pendingSendItem","itemToSend","sendError","event","readyState","OPEN"],"sources":["src/common.browser/WebsocketMessageAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n// Node.JS specific web socket / browser support.\r\nimport ws from \"ws\";\r\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\r\nimport {\r\n    ArgumentNullError,\r\n    BackgroundEvent,\r\n    ConnectionClosedEvent,\r\n    ConnectionErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    ConnectionOpenResponse,\r\n    ConnectionStartEvent,\r\n    ConnectionState,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Queue,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports\";\r\nimport { ProxyInfo } from \"./ProxyInfo\";\r\n\r\nimport { CertCheckAgent } from \"./CertChecks\";\r\n\r\ninterface ISendItem {\r\n    Message: ConnectionMessage;\r\n    RawWebsocketMessage: RawWebsocketMessage;\r\n    sendStatusDeferral: Deferred<void>;\r\n}\r\n\r\nexport class WebsocketMessageAdapter {\r\n    private privConnectionState: ConnectionState;\r\n    private privMessageFormatter: IWebsocketMessageFormatter;\r\n    private privWebsocketClient: WebSocket | ws;\r\n\r\n    private privSendMessageQueue: Queue<ISendItem>;\r\n    private privReceivingMessageQueue: Queue<ConnectionMessage>;\r\n    private privConnectionEstablishDeferral: Deferred<ConnectionOpenResponse>;\r\n    private privCertificateValidatedDeferral: Deferred<void>;\r\n    private privDisconnectDeferral: Deferred<void>;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privConnectionId: string;\r\n    private privUri: string;\r\n    private proxyInfo: ProxyInfo;\r\n    private privHeaders: { [key: string]: string };\r\n    private privLastErrorReceived: string;\r\n    private privEnableCompression: boolean;\r\n\r\n    public static forceNpmWebSocket: boolean = false;\r\n\r\n    public constructor(\r\n        uri: string,\r\n        connectionId: string,\r\n        messageFormatter: IWebsocketMessageFormatter,\r\n        proxyInfo: ProxyInfo,\r\n        headers: { [key: string]: string },\r\n        enableCompression: boolean) {\r\n\r\n        if (!uri) {\r\n            throw new ArgumentNullError(\"uri\");\r\n        }\r\n\r\n        if (!messageFormatter) {\r\n            throw new ArgumentNullError(\"messageFormatter\");\r\n        }\r\n\r\n        this.proxyInfo = proxyInfo;\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privConnectionId = connectionId;\r\n        this.privMessageFormatter = messageFormatter;\r\n        this.privConnectionState = ConnectionState.None;\r\n        this.privUri = uri;\r\n        this.privHeaders = headers;\r\n        this.privEnableCompression = enableCompression;\r\n\r\n        // Add the connection ID to the headers\r\n        this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\r\n\r\n        this.privLastErrorReceived = \"\";\r\n    }\r\n\r\n    public get state(): ConnectionState {\r\n        return this.privConnectionState;\r\n    }\r\n\r\n    public open(): Promise<ConnectionOpenResponse> {\r\n        if (this.privConnectionState === ConnectionState.Disconnected) {\r\n            return Promise.reject<ConnectionOpenResponse>(`Cannot open a connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        if (this.privConnectionEstablishDeferral) {\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.privConnectionEstablishDeferral = new Deferred<ConnectionOpenResponse>();\r\n        this.privCertificateValidatedDeferral = new Deferred<void>();\r\n\r\n        this.privConnectionState = ConnectionState.Connecting;\r\n\r\n        try {\r\n\r\n            if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\r\n                // Browser handles cert checks.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n\r\n                this.privWebsocketClient = new WebSocket(this.privUri);\r\n            } else {\r\n                const options: ws.ClientOptions = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };\r\n                // The ocsp library will handle validation for us and fail the connection if needed.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n                const checkAgent: CertCheckAgent = new CertCheckAgent(this.proxyInfo);\r\n\r\n                options.agent = checkAgent.GetAgent();\r\n\r\n                // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\r\n                // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\r\n                const uri = new URL(this.privUri);\r\n                let protocol: string = uri.protocol;\r\n\r\n                if (protocol?.toLocaleLowerCase() === \"wss:\") {\r\n                    protocol = \"https:\";\r\n                } else if (protocol?.toLocaleLowerCase() === \"ws:\") {\r\n                    protocol = \"http:\";\r\n                }\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n                (options.agent as any).protocol = protocol;\r\n                this.privWebsocketClient = new ws(this.privUri, options);\r\n            }\r\n\r\n            this.privWebsocketClient.binaryType = \"arraybuffer\";\r\n            this.privReceivingMessageQueue = new Queue<ConnectionMessage>();\r\n            this.privDisconnectDeferral = new Deferred<void>();\r\n            this.privSendMessageQueue = new Queue<ISendItem>();\r\n            this.processSendQueue().catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        } catch (error) {\r\n            this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error as string));\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\r\n\r\n        this.privWebsocketClient.onopen = (): void => {\r\n            this.privCertificateValidatedDeferral.promise.then((): void => {\r\n                this.privConnectionState = ConnectionState.Connected;\r\n                this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\r\n            }, (error: string): void => {\r\n                this.privConnectionEstablishDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onerror = (e: { error: any; message: string; type: string; target: WebSocket | ws }): void => {\r\n            this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\r\n            this.privLastErrorReceived = e.message;\r\n        };\r\n\r\n        this.privWebsocketClient.onclose = (e: { wasClean: boolean; code: number; reason: string; target: WebSocket | ws }): void => {\r\n            if (this.privConnectionState === ConnectionState.Connecting) {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\r\n            } else {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                this.privWebsocketClient = null;\r\n                this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\r\n            }\r\n\r\n            this.onClose(e.code, e.reason).catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onmessage = (e: { data: ws.Data; type: string; target: WebSocket | ws }): void => {\r\n            const networkReceivedTime = new Date().toISOString();\r\n            if (this.privConnectionState === ConnectionState.Connected) {\r\n                const deferred = new Deferred<ConnectionMessage>();\r\n                // let id = ++this.idCounter;\r\n                this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\r\n                if (e.data instanceof ArrayBuffer) {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage): void => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string): void => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid binary message format. Error: ${error}`);\r\n                        });\r\n                } else {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage): void => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string): void => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid text message format. Error: ${error}`);\r\n                        });\r\n                }\r\n            }\r\n        };\r\n\r\n        return this.privConnectionEstablishDeferral.promise;\r\n    }\r\n\r\n    public send(message: ConnectionMessage): Promise<void> {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\r\n        }\r\n\r\n        const messageSendStatusDeferral = new Deferred<void>();\r\n        const messageSendDeferral = new Deferred<ISendItem>();\r\n\r\n        this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\r\n\r\n        this.privMessageFormatter\r\n            .fromConnectionMessage(message)\r\n            .then((rawMessage: RawWebsocketMessage): void => {\r\n                messageSendDeferral.resolve({\r\n                    Message: message,\r\n                    RawWebsocketMessage: rawMessage,\r\n                    sendStatusDeferral: messageSendStatusDeferral,\r\n                });\r\n            }, (error: string): void => {\r\n                messageSendDeferral.reject(`Error formatting the message. ${error}`);\r\n            });\r\n\r\n        return messageSendStatusDeferral.promise;\r\n    }\r\n\r\n    public read(): Promise<ConnectionMessage> {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject<ConnectionMessage>(`Cannot read on connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        return this.privReceivingMessageQueue.dequeue();\r\n    }\r\n\r\n    public close(reason?: string): Promise<void> {\r\n        if (this.privWebsocketClient) {\r\n            if (this.privConnectionState !== ConnectionState.Disconnected) {\r\n                this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\r\n            }\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this.privDisconnectDeferral.promise;\r\n    }\r\n\r\n    public get events(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    private sendRawMessage(sendItem: ISendItem): Promise<void> {\r\n        try {\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\r\n\r\n            // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\r\n            if (this.isWebsocketOpen) {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\r\n                this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\r\n            } else {\r\n                return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\r\n            }\r\n            return Promise.resolve();\r\n\r\n        } catch (e) {\r\n            return Promise.reject(`websocket send error: ${e as string}`);\r\n        }\r\n    }\r\n\r\n    private async onClose(code: number, reason: string): Promise<void> {\r\n        const closeReason = `Connection closed. ${code}: ${reason}`;\r\n        this.privConnectionState = ConnectionState.Disconnected;\r\n        this.privDisconnectDeferral.resolve();\r\n        await this.privReceivingMessageQueue.drainAndDispose((): void => {\r\n            // TODO: Events for these ?\r\n            // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\r\n        }, closeReason);\r\n\r\n        await this.privSendMessageQueue.drainAndDispose((pendingSendItem: ISendItem): void => {\r\n            pendingSendItem.sendStatusDeferral.reject(closeReason);\r\n        }, closeReason);\r\n    }\r\n\r\n    private async processSendQueue(): Promise<void> {\r\n        while (true) {\r\n            const itemToSend: Promise<ISendItem> = this.privSendMessageQueue.dequeue();\r\n            const sendItem: ISendItem = await itemToSend;\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.sendRawMessage(sendItem);\r\n                sendItem.sendStatusDeferral.resolve();\r\n            } catch (sendError) {\r\n                sendItem.sendStatusDeferral.reject(sendError as string);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onEvent(event: ConnectionEvent): void {\r\n        this.privConnectionEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private get isWebsocketOpen(): boolean {\r\n        return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}