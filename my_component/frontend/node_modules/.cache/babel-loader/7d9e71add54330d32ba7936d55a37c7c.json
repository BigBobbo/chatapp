{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource } from \"../common/Exports\";\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\nexport class MicAudioSource {\n  constructor(privRecorder, deviceId, audioSourceId, mediaStream) {\n    this.privRecorder = privRecorder;\n    this.deviceId = deviceId;\n    this.privStreams = {};\n    this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n    this.privMediaStream = mediaStream || null;\n    this.privIsClosing = false;\n  }\n  get format() {\n    return Promise.resolve(MicAudioSource.AUDIOFORMAT);\n  }\n  get blob() {\n    return Promise.reject(\"Not implemented for Mic input\");\n  }\n  turnOn() {\n    if (this.privInitializeDeferral) {\n      return this.privInitializeDeferral.promise;\n    }\n    this.privInitializeDeferral = new Deferred();\n    try {\n      this.createAudioContext();\n    } catch (error) {\n      if (error instanceof Error) {\n        const typedError = error;\n        this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\n      } else {\n        this.privInitializeDeferral.reject(error);\n      }\n      return this.privInitializeDeferral.promise;\n    }\n    const nav = window.navigator;\n    let getUserMedia =\n    // eslint-disable-next-line\n    nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;\n    if (!!nav.mediaDevices) {\n      getUserMedia = (constraints, successCallback, errorCallback) => {\n        nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);\n      };\n    }\n    if (!getUserMedia) {\n      const errorMsg = \"Browser does not support getUserMedia.\";\n      this.privInitializeDeferral.reject(errorMsg);\n      this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n    } else {\n      const next = () => {\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        if (this.privMediaStream && this.privMediaStream.active) {\n          this.onEvent(new AudioSourceReadyEvent(this.privId));\n          this.privInitializeDeferral.resolve();\n        } else {\n          getUserMedia({\n            audio: this.deviceId ? {\n              deviceId: this.deviceId\n            } : true,\n            video: false\n          }, mediaStream => {\n            this.privMediaStream = mediaStream;\n            this.onEvent(new AudioSourceReadyEvent(this.privId));\n            this.privInitializeDeferral.resolve();\n          }, error => {\n            const errorMsg = `Error occurred during microphone initialization: ${error}`;\n            this.privInitializeDeferral.reject(errorMsg);\n            this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\n          });\n        }\n      };\n      if (this.privContext.state === \"suspended\") {\n        // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n        // https://github.com/WebAudio/web-audio-api/issues/790\n        this.privContext.resume().then(next).catch(reason => {\n          this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\n        });\n      } else {\n        next();\n      }\n    }\n    return this.privInitializeDeferral.promise;\n  }\n  id() {\n    return this.privId;\n  }\n  attach(audioNodeId) {\n    this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n    return this.listen(audioNodeId).then(stream => {\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return {\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          stream.readEnded();\n          delete this.privStreams[audioNodeId];\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          return this.turnOff();\n        }),\n        id: () => audioNodeId,\n        read: () => stream.read()\n      };\n    });\n  }\n  detach(audioNodeId) {\n    if (audioNodeId && this.privStreams[audioNodeId]) {\n      this.privStreams[audioNodeId].close();\n      delete this.privStreams[audioNodeId];\n      this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n  }\n  turnOff() {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const streamId in this.privStreams) {\n        if (streamId) {\n          const stream = this.privStreams[streamId];\n          if (stream) {\n            stream.close();\n          }\n        }\n      }\n      this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n      if (this.privInitializeDeferral) {\n        // Correctly handle when browser forces mic off before turnOn() completes\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        yield this.privInitializeDeferral;\n        this.privInitializeDeferral = null;\n      }\n      yield this.destroyAudioContext();\n      return;\n    });\n  }\n  get events() {\n    return this.privEvents;\n  }\n  get deviceInfo() {\n    return this.getMicrophoneLabel().then(label => ({\n      bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\n      channelcount: MicAudioSource.AUDIOFORMAT.channels,\n      connectivity: connectivity.Unknown,\n      manufacturer: \"Speech SDK\",\n      model: label,\n      samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\n      type: type.Microphones\n    }));\n  }\n  setProperty(name, value) {\n    if (name === AudioWorkletSourceURLPropertyName) {\n      this.privRecorder.setWorkletUrl(value);\n    } else {\n      throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\n    }\n  }\n  getMicrophoneLabel() {\n    const defaultMicrophoneName = \"microphone\";\n    // If we did this already, return the value.\n    if (this.privMicrophoneLabel !== undefined) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    }\n    // If the stream isn't currently running, we can't query devices because security.\n    if (this.privMediaStream === undefined || !this.privMediaStream.active) {\n      return Promise.resolve(defaultMicrophoneName);\n    }\n    // Setup a default\n    this.privMicrophoneLabel = defaultMicrophoneName;\n    // Get the id of the device running the audio track.\n    const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;\n    // If the browser doesn't support getting the device ID, set a default and return.\n    if (undefined === microphoneDeviceId) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    }\n    const deferred = new Deferred();\n    // Enumerate the media devices.\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      for (const device of devices) {\n        if (device.deviceId === microphoneDeviceId) {\n          // Found the device\n          this.privMicrophoneLabel = device.label;\n          break;\n        }\n      }\n      deferred.resolve(this.privMicrophoneLabel);\n    }, () => deferred.resolve(this.privMicrophoneLabel));\n    return deferred.promise;\n  }\n  listen(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.turnOn();\n      const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\n      this.privStreams[audioNodeId] = stream;\n      try {\n        this.privRecorder.record(this.privContext, this.privMediaStream, stream);\n      } catch (error) {\n        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\n        throw error;\n      }\n      const result = stream;\n      return result;\n    });\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n  createAudioContext() {\n    if (!!this.privContext) {\n      return;\n    }\n    this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\n  }\n  destroyAudioContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privContext) {\n        return;\n      }\n      this.privRecorder.releaseMediaResources(this.privContext);\n      // This pattern brought to you by a bug in the TypeScript compiler where it\n      // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\n      // https://github.com/Microsoft/TypeScript/issues/11498\n      let hasClose = false;\n      if (\"close\" in this.privContext) {\n        hasClose = true;\n      }\n      if (hasClose) {\n        if (!this.privIsClosing) {\n          // The audio context close may take enough time that the close is called twice\n          this.privIsClosing = true;\n          yield this.privContext.close();\n          this.privContext = null;\n          this.privIsClosing = false;\n        }\n      } else if (null !== this.privContext && this.privContext.state === \"running\") {\n        // Suspend actually takes a callback, but analogous to the\n        // resume method, it'll be only fired if suspend is called\n        // in a direct response to a user action. The later is not always\n        // the case, as TurnOff is also called, when we receive an\n        // end-of-speech message from the service. So, doing a best effort\n        // fire-and-forget here.\n        yield this.privContext.suspend();\n      }\n    });\n  }\n}\nMicAudioSource.AUDIOFORMAT = AudioStreamFormat.getDefaultInputFormat();","map":{"version":3,"mappings":"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","names":["connectivity","type","AudioSourceErrorEvent","AudioSourceInitializingEvent","AudioSourceOffEvent","AudioSourceReadyEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ChunkedArrayBufferStream","createNoDashGuid","Deferred","Events","EventSource","AudioStreamFormat","AudioStreamFormatImpl","AudioWorkletSourceURLPropertyName","MicAudioSource","constructor","privRecorder","deviceId","audioSourceId","mediaStream","privOutputChunkSize","AUDIOFORMAT","avgBytesPerSec","privId","privEvents","privMediaStream","privIsClosing","format","Promise","resolve","blob","reject","turnOn","privInitializeDeferral","promise","createAudioContext","error","Error","typedError","name","message","nav","window","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","mediaDevices","constraints","successCallback","errorCallback","then","catch","errorMsg","onEvent","next","active","audio","video","privContext","state","resume","reason","id","attach","audioNodeId","listen","stream","detach","__awaiter","readEnded","privStreams","turnOff","read","close","streamId","destroyAudioContext","events","deviceInfo","getMicrophoneLabel","label","bitspersample","bitsPerSample","channelcount","channels","Unknown","manufacturer","model","samplerate","samplesPerSec","Microphones","setProperty","value","setWorkletUrl","defaultMicrophoneName","privMicrophoneLabel","undefined","microphoneDeviceId","getTracks","getSettings","deferred","enumerateDevices","devices","device","record","result","event","instance","getAudioContext","releaseMediaResources","hasClose","suspend","getDefaultInputFormat"],"sources":["src/common.browser/MicAudioSource.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { IStreamChunk } from \"../common/Stream\";\r\nimport {\r\n    AudioStreamFormat,\r\n    AudioStreamFormatImpl,\r\n} from \"../sdk/Audio/AudioStreamFormat\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// Extending the default definition with browser specific definitions for backward compatibility\r\ninterface INavigator extends Navigator {\r\n    webkitGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback | undefined, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    mozGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback | undefined, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    msGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n}\r\n\r\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\r\n\r\nexport class MicAudioSource implements IAudioSource {\r\n\r\n    private static readonly AUDIOFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privInitializeDeferral: Deferred<void>;\r\n\r\n    private privMediaStream: MediaStream;\r\n\r\n    private privContext: AudioContext;\r\n\r\n    private privMicrophoneLabel: string;\r\n\r\n    private privOutputChunkSize: number;\r\n\r\n    private privIsClosing: boolean;\r\n\r\n    public constructor(\r\n        private readonly privRecorder: IRecorder,\r\n        private readonly deviceId?: string,\r\n        audioSourceId?: string,\r\n        mediaStream?: MediaStream\r\n        ) {\r\n\r\n        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privMediaStream = mediaStream || null;\r\n        this.privIsClosing = false;\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return Promise.resolve(MicAudioSource.AUDIOFORMAT);\r\n    }\r\n\r\n    public get blob(): Promise<Blob> {\r\n        return Promise.reject(\"Not implemented for Mic input\");\r\n    }\r\n\r\n    public turnOn(): Promise<void> {\r\n        if (this.privInitializeDeferral) {\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        this.privInitializeDeferral = new Deferred<void>();\r\n\r\n        try {\r\n            this.createAudioContext();\r\n        } catch (error) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error;\r\n                this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\r\n            } else {\r\n                this.privInitializeDeferral.reject(error as string);\r\n            }\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        const nav = window.navigator as INavigator;\r\n\r\n        let getUserMedia = (\r\n            // eslint-disable-next-line\r\n            nav.getUserMedia ||\r\n            nav.webkitGetUserMedia ||\r\n            nav.mozGetUserMedia ||\r\n            nav.msGetUserMedia\r\n        );\r\n\r\n        if (!!nav.mediaDevices) {\r\n            getUserMedia = (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void => {\r\n                nav.mediaDevices\r\n                    .getUserMedia(constraints)\r\n                    .then(successCallback)\r\n                    .catch(errorCallback);\r\n            };\r\n        }\r\n\r\n        if (!getUserMedia) {\r\n            const errorMsg = \"Browser does not support getUserMedia.\";\r\n            this.privInitializeDeferral.reject(errorMsg);\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\r\n        } else {\r\n            const next = (): void => {\r\n                this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n                if (this.privMediaStream && this.privMediaStream.active) {\r\n                    this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                    this.privInitializeDeferral.resolve();\r\n                } else {\r\n                    getUserMedia(\r\n                        { audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false },\r\n                        (mediaStream: MediaStream): void => {\r\n                            this.privMediaStream = mediaStream;\r\n                            this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                            this.privInitializeDeferral.resolve();\r\n                        }, (error: any): void => {\r\n                            const errorMsg = `Error occurred during microphone initialization: ${error as string}`;\r\n                            this.privInitializeDeferral.reject(errorMsg);\r\n                            this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\r\n                        });\r\n                }\r\n            };\r\n\r\n            if (this.privContext.state === \"suspended\") {\r\n                // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\r\n                // https://github.com/WebAudio/web-audio-api/issues/790\r\n                this.privContext.resume()\r\n                    .then(next)\r\n                    .catch((reason: any): void => {\r\n                        this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason as string}`);\r\n                    });\r\n            } else {\r\n                next();\r\n            }\r\n        }\r\n\r\n        return this.privInitializeDeferral.promise;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach(audioNodeId: string): Promise<IAudioStreamNode> {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.listen(audioNodeId).then<IAudioStreamNode>(\r\n            (stream: Stream<ArrayBuffer>): IAudioStreamNode => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: async (): Promise<void> => {\r\n                        stream.readEnded();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                        return this.turnOff();\r\n                    },\r\n                    id: (): string => audioNodeId,\r\n                    read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach(audioNodeId: string): void {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public async turnOff(): Promise<void> {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        if (this.privInitializeDeferral) {\r\n            // Correctly handle when browser forces mic off before turnOn() completes\r\n            // eslint-disable-next-line @typescript-eslint/await-thenable\r\n            await this.privInitializeDeferral;\r\n            this.privInitializeDeferral = null;\r\n        }\r\n\r\n        await this.destroyAudioContext();\r\n\r\n        return;\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.getMicrophoneLabel().then((label: string): ISpeechConfigAudioDevice => (\r\n            {\r\n                bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\r\n                channelcount: MicAudioSource.AUDIOFORMAT.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: label,\r\n                samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\r\n                type: type.Microphones,\r\n            }\r\n        ));\r\n    }\r\n\r\n    public setProperty(name: string, value: string): void {\r\n        if (name === AudioWorkletSourceURLPropertyName) {\r\n            this.privRecorder.setWorkletUrl(value);\r\n        } else {\r\n            throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\r\n        }\r\n    }\r\n\r\n    private getMicrophoneLabel(): Promise<string> {\r\n        const defaultMicrophoneName: string = \"microphone\";\r\n\r\n        // If we did this already, return the value.\r\n        if (this.privMicrophoneLabel !== undefined) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        // If the stream isn't currently running, we can't query devices because security.\r\n        if (this.privMediaStream === undefined || !this.privMediaStream.active) {\r\n            return Promise.resolve(defaultMicrophoneName);\r\n        }\r\n\r\n        // Setup a default\r\n        this.privMicrophoneLabel = defaultMicrophoneName;\r\n\r\n        // Get the id of the device running the audio track.\r\n        const microphoneDeviceId: string = this.privMediaStream.getTracks()[0].getSettings().deviceId;\r\n\r\n        // If the browser doesn't support getting the device ID, set a default and return.\r\n        if (undefined === microphoneDeviceId) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        const deferred: Deferred<string> = new Deferred<string>();\r\n\r\n        // Enumerate the media devices.\r\n        navigator.mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]): void => {\r\n            for (const device of devices) {\r\n                if (device.deviceId === microphoneDeviceId) {\r\n                    // Found the device\r\n                    this.privMicrophoneLabel = device.label;\r\n                    break;\r\n                }\r\n            }\r\n            deferred.resolve(this.privMicrophoneLabel);\r\n        }, (): Deferred<string> => deferred.resolve(this.privMicrophoneLabel));\r\n\r\n        return deferred.promise;\r\n    }\r\n\r\n    private async listen(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        await this.turnOn();\r\n        const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\r\n        this.privStreams[audioNodeId] = stream;\r\n        try {\r\n            this.privRecorder.record(this.privContext, this.privMediaStream, stream);\r\n        } catch (error) {\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error as string));\r\n            throw error;\r\n        }\r\n        const result: Stream<ArrayBuffer> = stream;\r\n        return result;\r\n    }\r\n\r\n    private onEvent(event: AudioSourceEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private createAudioContext(): void {\r\n        if (!!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\r\n    }\r\n\r\n    private async destroyAudioContext(): Promise<void> {\r\n        if (!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privRecorder.releaseMediaResources(this.privContext);\r\n\r\n        // This pattern brought to you by a bug in the TypeScript compiler where it\r\n        // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\r\n        // https://github.com/Microsoft/TypeScript/issues/11498\r\n        let hasClose: boolean = false;\r\n        if (\"close\" in this.privContext) {\r\n            hasClose = true;\r\n        }\r\n\r\n        if (hasClose) {\r\n            if (!this.privIsClosing) {\r\n                // The audio context close may take enough time that the close is called twice\r\n                this.privIsClosing = true;\r\n                await this.privContext.close();\r\n                this.privContext = null;\r\n                this.privIsClosing = false;\r\n            }\r\n        } else if (null !== this.privContext && this.privContext.state === \"running\") {\r\n            // Suspend actually takes a callback, but analogous to the\r\n            // resume method, it'll be only fired if suspend is called\r\n            // in a direct response to a user action. The later is not always\r\n            // the case, as TurnOff is also called, when we receive an\r\n            // end-of-speech message from the service. So, doing a best effort\r\n            // fire-and-forget here.\r\n            await this.privContext.suspend();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}