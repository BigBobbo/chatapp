{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class SynthesisAdapterBase {\n  constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {\n    this.speakOverride = undefined;\n    this.receiveMessageOverride = undefined;\n    this.connectImplOverride = undefined;\n    this.configConnectionOverride = undefined;\n    // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n    this.privConnectionConfigurationPromise = undefined;\n    if (!authentication) {\n      throw new ArgumentNullError(\"authentication\");\n    }\n    if (!connectionFactory) {\n      throw new ArgumentNullError(\"connectionFactory\");\n    }\n    if (!synthesizerConfig) {\n      throw new ArgumentNullError(\"synthesizerConfig\");\n    }\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privSynthesizerConfig = synthesizerConfig;\n    this.privIsDisposed = false;\n    this.privSpeechSynthesizer = speechSynthesizer;\n    this.privSessionAudioDestination = audioDestination;\n    this.privSynthesisTurn = new SynthesisTurn();\n    this.privConnectionEvents = new EventSource();\n    this.privServiceEvents = new EventSource();\n    this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n    this.privAgentConfig = new AgentConfig();\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n        if (connectionClosedEvent.statusCode !== 1000) {\n          this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n        }\n      }\n    });\n  }\n  get synthesisContext() {\n    return this.privSynthesisContext;\n  }\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n    this.privSynthesisTurn.audioOutputFormat = format;\n    if (this.privSessionAudioDestination !== undefined) {\n      this.privSessionAudioDestination.format = format;\n    }\n    if (this.synthesisContext !== undefined) {\n      this.synthesisContext.audioOutputFormat = format;\n    }\n  }\n  static addHeader(audio, format) {\n    if (!format.hasHeader) {\n      return audio;\n    }\n    format.updateHeader(audio.byteLength);\n    const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n    tmp.set(new Uint8Array(format.header), 0);\n    tmp.set(new Uint8Array(audio), format.header.byteLength);\n    return tmp.buffer;\n  }\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.close();\n      }\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        const connection = yield this.privConnectionConfigurationPromise;\n        yield connection.dispose(reason);\n      }\n    });\n  }\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n    });\n  }\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    });\n  }\n  Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ssml;\n      if (isSSML) {\n        ssml = text;\n      } else {\n        ssml = this.privSpeechSynthesizer.buildSsml(text);\n      }\n      if (this.speakOverride !== undefined) {\n        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n      }\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n      try {\n        yield this.connectImpl();\n        const connection = yield this.fetchConnection();\n        yield this.sendSynthesisContext(connection);\n        yield this.sendSsmlMessage(connection, ssml, requestId);\n        const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));\n        if (!!this.privSpeechSynthesizer.synthesisStarted) {\n          this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n        }\n        void this.receiveMessage();\n      } catch (e) {\n        this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n        return Promise.reject(e);\n      }\n    });\n  }\n  // Cancels synthesis.\n  cancelSynthesis(requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n    if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n      const cancelEvent = new SpeechSynthesisEventArgs(result);\n      try {\n        this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n    if (!!this.privSuccessCallback) {\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n      } catch (_b) {}\n    }\n  }\n  // Cancels synthesis.\n  cancelSynthesisLocal(cancellationReason, errorCode, error) {\n    if (!!this.privSynthesisTurn.isSynthesizing) {\n      this.privSynthesisTurn.onStopSynthesizing();\n      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  processTypeSpecificMessages(connectionMessage) {\n    return true;\n  }\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        }\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        }\n        // indicates we are draining the queue and it came with no message;\n        if (!message) {\n          if (!this.privSynthesisTurn.isSynthesizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privSynthesisTurn.onServiceTurnStartResponse();\n              break;\n            case \"response\":\n              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n              break;\n            case \"audio\":\n              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                if (!!this.privSpeechSynthesizer.synthesizing) {\n                  try {\n                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                    const ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));\n                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                  } catch (error) {\n                    // Not going to let errors in the event handler\n                    // trip things up.\n                  }\n                }\n                if (this.privSessionAudioDestination !== undefined) {\n                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                }\n              }\n              break;\n            case \"audio.metadata\":\n              const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n              for (const metadata of metadataList) {\n                switch (metadata.Type) {\n                  case MetadataType.WordBoundary:\n                  case MetadataType.SentenceBoundary:\n                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n                    const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);\n                    if (!!this.privSpeechSynthesizer.wordBoundary) {\n                      try {\n                        this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                      } catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n                    break;\n                  case MetadataType.Bookmark:\n                    const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                      try {\n                        this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                      } catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n                    break;\n                  case MetadataType.Viseme:\n                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                    if (metadata.Data.IsLastAnimation) {\n                      const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n                      if (!!this.privSpeechSynthesizer.visemeReceived) {\n                        try {\n                          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                        } catch (error) {\n                          // Not going to let errors in the event handler\n                          // trip things up.\n                        }\n                      }\n                    }\n                    break;\n                  case MetadataType.SessionEnd:\n                    this.privSynthesisTurn.onSessionEnd(metadata);\n                    break;\n                }\n              }\n              break;\n            case \"turn.end\":\n              this.privSynthesisTurn.onServiceTurnEndResponse();\n              let result;\n              try {\n                const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, undefined, this.privSynthesisTurn.audioDuration);\n                if (!!this.privSuccessCallback) {\n                  this.privSuccessCallback(result);\n                }\n              } catch (error) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(error);\n                }\n              }\n              if (this.privSpeechSynthesizer.synthesisCompleted) {\n                try {\n                  this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));\n                } catch (e) {\n                  // Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n              break;\n            default:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n          }\n        }\n        return this.receiveMessage();\n      } catch (e) {\n        // TODO: What goes here?\n      }\n    });\n  }\n  sendSynthesisContext(connection) {\n    const synthesisContextJson = this.synthesisContext.toJSON();\n    if (synthesisContextJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n    }\n    return;\n  }\n  connectImpl() {\n    let isUnAuthorized = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.privConnectionPromise != null) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          return this.connectImpl();\n        }\n        return this.privConnectionPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        return this.connectImpl();\n      });\n    }\n    this.privAuthFetchEventId = createNoDashGuid();\n    this.privConnectionId = createNoDashGuid();\n    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n    this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n      this.privSynthesisTurn.onAuthCompleted(false);\n      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n      // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      const response = yield connection.open();\n      if (response.statusCode === 200) {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.resolve(connection);\n      } else if (response.statusCode === 403 && !isUnAuthorized) {\n        return this.connectImpl(true);\n      } else {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n      }\n    }), error => {\n      this.privSynthesisTurn.onAuthCompleted(true);\n      throw new Error(error);\n    });\n    // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    this.privConnectionPromise.catch(() => {});\n    return this.privConnectionPromise;\n  }\n  sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {\n    if (SpeechServiceConfigJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n    }\n  }\n  sendSsmlMessage(connection, ssml, requestId) {\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n  }\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            return this.fetchConnection();\n          }\n          return this.privConnectionConfigurationPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = undefined;\n          return this.fetchConnection();\n        });\n      }\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  }\n  // Takes an established websocket connection to the endpoint and sends speech configuration information.\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n      yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n      return connection;\n    });\n  }\n}\nSynthesisAdapterBase.telemetryDataEnabled = true;","map":{"version":3,"mappings":"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","names":["ArgumentNullError","ConnectionState","createNoDashGuid","EventSource","MessageType","ServiceEvent","CancellationErrorCode","CancellationReason","PropertyCollection","PropertyId","ResultReason","SpeechSynthesisBookmarkEventArgs","SpeechSynthesisEventArgs","SpeechSynthesisResult","SpeechSynthesisVisemeEventArgs","SpeechSynthesisWordBoundaryEventArgs","AgentConfig","CancellationErrorCodePropertyName","MetadataType","SynthesisAudioMetadata","SynthesisContext","SynthesisTurn","SpeechConnectionMessage","SynthesisAdapterBase","constructor","authentication","connectionFactory","synthesizerConfig","speechSynthesizer","audioDestination","undefined","privAuthentication","privConnectionFactory","privSynthesizerConfig","privIsDisposed","privSpeechSynthesizer","privSessionAudioDestination","privSynthesisTurn","privConnectionEvents","privServiceEvents","privSynthesisContext","privAgentConfig","connectionEvents","attach","connectionEvent","name","connectionClosedEvent","statusCode","cancelSynthesisLocal","Error","BadRequestParameters","ConnectionFailure","reason","synthesisContext","agentConfig","serviceEvents","activityTemplate","messagePayload","privActivityTemplate","audioOutputFormat","format","privAudioOutputFormat","addHeader","audio","hasHeader","updateHeader","byteLength","tmp","Uint8Array","header","set","buffer","isDisposed","dispose","close","privConnectionConfigurationPromise","connection","connect","connectImpl","sendNetworkMessage","path","payload","type","Text","Binary","contentType","fetchConnection","send","requestId","Speak","text","isSSML","successCallback","errorCallBack","ssml","buildSsml","speakOverride","privSuccessCallback","privErrorCallback","startNewSynthesis","sendSynthesisContext","sendSsmlMessage","synthesisStartEventArgs","SynthesizingAudioStarted","synthesisStarted","receiveMessage","e","Promise","reject","cancelSynthesis","cancellationReason","errorCode","error","properties","setProperty","result","Canceled","SynthesisCanceled","cancelEvent","isSynthesizing","onStopSynthesizing","processTypeSpecificMessages","connectionMessage","message","read","receiveMessageOverride","fromConnectionMessage","toLowerCase","onServiceTurnStartResponse","onServiceResponseMessage","textBody","streamId","binaryBody","onAudioChunkReceived","synthesizing","audioWithHeader","ev","SynthesizingAudio","write","metadataList","fromJSON","Metadata","metadata","Type","WordBoundary","SentenceBoundary","onTextBoundaryEvent","wordBoundaryEventArgs","Data","Offset","Duration","Length","currentTextOffset","currentSentenceOffset","BoundaryType","wordBoundary","Bookmark","bookmarkEventArgs","bookmarkReached","Viseme","onVisemeMetadataReceived","IsLastAnimation","visemeEventArgs","VisemeId","getAndClearVisemeAnimation","visemeReceived","SessionEnd","onSessionEnd","onServiceTurnEndResponse","audioBuffer","getAllReceivedAudioWithHeader","SynthesizingAudioCompleted","audioDuration","synthesisCompleted","onEvent","synthesisContextJson","toJSON","isUnAuthorized","privConnectionPromise","then","state","Disconnected","privConnectionId","privAuthFetchEventId","onPreConnectionStart","authPromise","fetchOnExpiry","fetch","__awaiter","onAuthCompleted","create","events","event","response","open","onConnectionEstablishCompleted","resolve","parameters","getProperty","SpeechServiceConnection_Endpoint","catch","sendSpeechServiceConfig","SpeechServiceConfigJson","configureConnection","configConnectionOverride","SpeechServiceConfig","serialize"],"sources":["src/common.speech/SynthesisAdapterBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"../sdk/Exports\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSpeechSynthesizer: SpeechSynthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => void = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) {\r\n        this.privActivityTemplate = messagePayload;\r\n    }\r\n    public get activityTemplate(): string {\r\n        return this.privActivityTemplate;\r\n    }\r\n\r\n    protected receiveMessageOverride: () => void = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => void = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection> = undefined;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privActivityTemplate: string;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        speechSynthesizer: SpeechSynthesizer,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSpeechSynthesizer = speechSynthesizer;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\r\n        if (!format.hasHeader) {\r\n            return audio;\r\n        }\r\n        format.updateHeader(audio.byteLength);\r\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\r\n        tmp.set(new Uint8Array(format.header), 0);\r\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\r\n        return tmp.buffer;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                new SpeechSynthesisResult(\r\n                    requestId,\r\n                    ResultReason.SynthesizingAudioStarted,\r\n                )\r\n            );\r\n\r\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\r\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\r\n            }\r\n\r\n            void this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e as string);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\r\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\r\n            try {\r\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\r\n                                try {\r\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\r\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                                        new SpeechSynthesisResult(\r\n                                            this.privSynthesisTurn.requestId,\r\n                                            ResultReason.SynthesizingAudio,\r\n                                            audioWithHeader));\r\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\r\n                                } catch (error) {\r\n                                    // Not going to let errors in the event handler\r\n                                    // trip things up.\r\n                                }\r\n                            }\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                case MetadataType.SentenceBoundary:\r\n                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\r\n\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Duration,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        metadata.Type === MetadataType.WordBoundary\r\n                                            ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset,\r\n                                        metadata.Data.text.BoundaryType);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n\r\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\r\n                                            try {\r\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\r\n                                            } catch (error) {\r\n                                                // Not going to let errors in the event handler\r\n                                                // trip things up.\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.SessionEnd:\r\n                                    this.privSynthesisTurn.onSessionEnd(metadata);\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\r\n                            result = new SpeechSynthesisResult(\r\n                                this.privSynthesisTurn.requestId,\r\n                                ResultReason.SynthesizingAudioCompleted,\r\n                                audioBuffer,\r\n                                undefined,\r\n                                undefined,\r\n                                this.privSynthesisTurn.audioDuration\r\n                            );\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error as string);\r\n                            }\r\n                        }\r\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\r\n                            try {\r\n                                this.privSpeechSynthesizer.synthesisCompleted(\r\n                                    this.privSpeechSynthesizer,\r\n                                    new SpeechSynthesisEventArgs(result)\r\n                                );\r\n                            } catch (e) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext(connection: IConnection): Promise<void> {\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise != null) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent): void => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, (error: string): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(true);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        this.privConnectionPromise.catch((): void => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig(connection: IConnection, SpeechServiceConfigJson: string): Promise<void> {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage(connection: IConnection, ssml: string, requestId: string): Promise<void> {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = undefined;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = undefined;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}