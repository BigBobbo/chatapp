{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\nimport { BackgroundEvent, createNoDashGuid, Events } from \"../../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\nconst MediaDurationPlaceholderSeconds = 60 * 30;\nconst AudioFormatToMimeType = {\n  [AudioFormatTag.PCM]: \"audio/wav\",\n  [AudioFormatTag.MuLaw]: \"audio/x-wav\",\n  [AudioFormatTag.MP3]: \"audio/mpeg\",\n  [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\n  [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\n  [AudioFormatTag.ALaw]: \"audio/x-wav\",\n  [AudioFormatTag.FLAC]: \"audio/flac\"\n};\n/**\n * Represents the speaker playback audio destination, which only works in browser.\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\n * @class SpeakerAudioDestination\n * Updated in version 1.17.0\n */\nexport class SpeakerAudioDestination {\n  constructor(audioDestinationId) {\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privBytesReceived = 0;\n    this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n  id() {\n    return this.privId;\n  }\n  write(buffer, cb, err) {\n    if (this.privAudioBuffer !== undefined) {\n      this.privAudioBuffer.push(buffer);\n      this.updateSourceBuffer().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined) {\n      this.privAudioOutputStream.write(buffer);\n      this.privBytesReceived += buffer.byteLength;\n    }\n  }\n  close(cb, err) {\n    this.privIsClosed = true;\n    if (this.privSourceBuffer !== undefined) {\n      this.handleSourceBufferUpdateEnd().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined && typeof window !== \"undefined\") {\n      if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Play back is not supported for raw PCM, mulaw or alaw format without header.\");\n        if (!!this.onAudioEnd) {\n          this.onAudioEnd(this);\n        }\n      } else {\n        let receivedAudio = new ArrayBuffer(this.privBytesReceived);\n        this.privAudioOutputStream.read(receivedAudio).then(() => {\n          receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\n          const audioBlob = new Blob([receivedAudio], {\n            type: AudioFormatToMimeType[this.privFormat.formatTag]\n          });\n          this.privAudio.src = window.URL.createObjectURL(audioBlob);\n          this.notifyPlayback().then(() => {\n            if (!!cb) {\n              cb();\n            }\n          }, error => {\n            if (!!err) {\n              err(error);\n            }\n          });\n        }, error => {\n          if (!!err) {\n            err(error);\n          }\n        });\n      }\n    } else {\n      // unsupported format, call onAudioEnd directly.\n      if (!!this.onAudioEnd) {\n        this.onAudioEnd(this);\n      }\n    }\n  }\n  set format(format) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (typeof AudioContext !== \"undefined\" || typeof window !== \"undefined\" && typeof window.webkitAudioContext !== \"undefined\") {\n      this.privFormat = format;\n      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n      if (mimeType === undefined) {\n        // eslint-disable-next-line no-console\n        console.warn(`Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\n      } else if (typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n        this.privAudio = new Audio();\n        this.privAudioBuffer = [];\n        this.privMediaSource = new MediaSource();\n        this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n        this.privAudio.load();\n        this.privMediaSource.onsourceopen = () => {\n          this.privMediaSourceOpened = true;\n          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\n          this.privSourceBuffer.onupdate = () => {\n            this.updateSourceBuffer().catch(reason => {\n              Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n          };\n          this.privSourceBuffer.onupdateend = () => {\n            this.handleSourceBufferUpdateEnd().catch(reason => {\n              Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n          };\n          this.privSourceBuffer.onupdatestart = () => {\n            this.privAppendingToBuffer = false;\n          };\n        };\n        this.updateSourceBuffer().catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(`Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n        this.privAudioOutputStream.format = this.privFormat;\n        this.privAudio = new Audio();\n      }\n    }\n  }\n  get volume() {\n    var _a, _b;\n    return (_b = (_a = this.privAudio) === null || _a === void 0 ? void 0 : _a.volume) !== null && _b !== void 0 ? _b : -1;\n  }\n  set volume(volume) {\n    if (!!this.privAudio) {\n      this.privAudio.volume = volume;\n    }\n  }\n  mute() {\n    if (!!this.privAudio) {\n      this.privAudio.muted = true;\n    }\n  }\n  unmute() {\n    if (!!this.privAudio) {\n      this.privAudio.muted = false;\n    }\n  }\n  get isClosed() {\n    return this.privIsClosed;\n  }\n  get currentTime() {\n    if (this.privAudio !== undefined) {\n      return this.privAudio.currentTime;\n    }\n    return -1;\n  }\n  pause() {\n    if (!this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.pause();\n      this.privIsPaused = true;\n    }\n  }\n  resume(cb, err) {\n    if (this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.play().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.privIsPaused = false;\n    }\n  }\n  get internalAudio() {\n    return this.privAudio;\n  }\n  updateSourceBuffer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n        this.privAppendingToBuffer = true;\n        const binary = this.privAudioBuffer.shift();\n        try {\n          this.privSourceBuffer.appendBuffer(binary);\n        } catch (error) {\n          this.privAudioBuffer.unshift(binary);\n          // eslint-disable-next-line no-console\n          console.log(\"buffer filled, pausing addition of binaries until space is made\");\n          return;\n        }\n        yield this.notifyPlayback();\n      } else if (this.canEndStream()) {\n        yield this.handleSourceBufferUpdateEnd();\n      }\n    });\n  }\n  handleSourceBufferUpdateEnd() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.canEndStream() && this.sourceBufferAvailable()) {\n        this.privMediaSource.endOfStream();\n        yield this.notifyPlayback();\n      }\n    });\n  }\n  notifyPlayback() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n        this.privPlaybackStarted = true;\n        if (!!this.onAudioStart) {\n          this.onAudioStart(this);\n        }\n        this.privAudio.onended = () => {\n          if (!!this.onAudioEnd) {\n            this.onAudioEnd(this);\n          }\n        };\n        if (!this.privIsPaused) {\n          yield this.privAudio.play();\n        }\n      }\n    });\n  }\n  canEndStream() {\n    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n  }\n  sourceBufferAvailable() {\n    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n  }\n}","map":{"version":3,"mappings":"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","names":["SynthesisAdapterBase","BackgroundEvent","createNoDashGuid","Events","PullAudioOutputStreamImpl","AudioFormatTag","MediaDurationPlaceholderSeconds","AudioFormatToMimeType","PCM","MuLaw","MP3","OGG_OPUS","WEBM_OPUS","ALaw","FLAC","SpeakerAudioDestination","constructor","audioDestinationId","privId","privIsPaused","privIsClosed","id","write","buffer","cb","err","privAudioBuffer","undefined","push","updateSourceBuffer","then","error","privAudioOutputStream","privBytesReceived","byteLength","close","privSourceBuffer","handleSourceBufferUpdateEnd","window","privFormat","formatTag","hasHeader","console","warn","onAudioEnd","receivedAudio","ArrayBuffer","read","addHeader","audioBlob","Blob","type","privAudio","src","URL","createObjectURL","notifyPlayback","format","AudioContext","webkitAudioContext","mimeType","MediaSource","isTypeSupported","Audio","privMediaSource","load","onsourceopen","privMediaSourceOpened","duration","addSourceBuffer","onupdate","catch","reason","instance","onEvent","onupdateend","onupdatestart","privAppendingToBuffer","volume","mute","muted","unmute","isClosed","currentTime","pause","resume","play","internalAudio","length","sourceBufferAvailable","binary","shift","appendBuffer","unshift","log","canEndStream","endOfStream","privPlaybackStarted","onAudioStart","onended","readyState","updating"],"sources":["src/sdk/Audio/SpeakerAudioDestination.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\r\nimport {\r\n    BackgroundEvent,\r\n    createNoDashGuid,\r\n    Events,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\r\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MuLaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n    [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\r\n    [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\r\n    [AudioFormatTag.ALaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.FLAC]: \"audio/flac\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.17.0\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privBytesReceived: number = 0;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer, cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            this.privAudioOutputStream.write(buffer);\r\n            this.privBytesReceived += buffer.byteLength;\r\n        }\r\n    }\r\n\r\n    public close(cb?: () => void, err?: (error: string) => void): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined && typeof window !== \"undefined\") {\r\n            if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw\r\n                || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\"Play back is not supported for raw PCM, mulaw or alaw format without header.\");\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            } else {\r\n                let receivedAudio = new ArrayBuffer(this.privBytesReceived);\r\n                this.privAudioOutputStream.read(receivedAudio).then((): void => {\r\n                    receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\r\n                    const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\r\n                    this.privAudio.src = window.URL.createObjectURL(audioBlob);\r\n                    this.notifyPlayback().then((): void => {\r\n                        if (!!cb) {\r\n                            cb();\r\n                        }\r\n                    }, (error: string): void => {\r\n                        if (!!err) {\r\n                            err(error);\r\n                        }\r\n                    });\r\n                }, (error: string): void => {\r\n                    if (!!err) {\r\n                        err(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // unsupported format, call onAudioEnd directly.\r\n            if (!!this.onAudioEnd) {\r\n                this.onAudioEnd(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    public set format(format: AudioStreamFormat) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n        if (typeof (AudioContext) !== \"undefined\" || (typeof (window) !== \"undefined\" && typeof ((window as any).webkitAudioContext) !== \"undefined\")) {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType === undefined) {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\r\n                    `Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\r\n\r\n            } else if (typeof (MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\r\n                    this.privSourceBuffer.onupdate = (): void => {\r\n                        this.updateSourceBuffer().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (): void => {\r\n                        this.handleSourceBufferUpdateEnd().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (): void => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer().catch((reason: string): void => {\r\n                    Events.instance.onEvent(new BackgroundEvent(reason));\r\n                });\r\n\r\n            } else {\r\n                // eslint-disable-next-line no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\r\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n                this.privAudioOutputStream.format = this.privFormat;\r\n                this.privAudio = new Audio();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get volume(): number {\r\n        return this.privAudio?.volume ?? -1;\r\n    }\r\n\r\n    public set volume(volume: number) {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.volume = volume;\r\n        }\r\n    }\r\n\r\n    public mute(): void {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.muted = true;\r\n        }\r\n    }\r\n\r\n    public unmute(): void {\r\n        if (!!this.privAudio) {\r\n            this.privAudio.muted = false;\r\n        }\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play().then((): void => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioStart: (sender: IPlayer) => void;\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private async updateSourceBuffer(): Promise<void> {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // eslint-disable-next-line no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            await this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            await this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private async handleSourceBufferUpdateEnd(): Promise<void> {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            await this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private async notifyPlayback(): Promise<void> {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privPlaybackStarted = true;\r\n            if (!!this.onAudioStart) {\r\n                this.onAudioStart(this);\r\n            }\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                await this.privAudio.play();\r\n            }\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}