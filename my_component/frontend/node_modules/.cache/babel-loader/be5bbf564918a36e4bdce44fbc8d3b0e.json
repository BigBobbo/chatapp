{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport bent from \"bent\";\nimport { ArgumentNullError, Deferred } from \"../common/Exports\";\nexport var RestRequestType;\n(function (RestRequestType) {\n  RestRequestType[\"Get\"] = \"GET\";\n  RestRequestType[\"Post\"] = \"POST\";\n  RestRequestType[\"Delete\"] = \"DELETE\";\n  RestRequestType[\"File\"] = \"file\";\n})(RestRequestType || (RestRequestType = {}));\n// accept rest operations via request method and return abstracted objects from server response\nexport class RestMessageAdapter {\n  constructor(configParams) {\n    if (!configParams) {\n      throw new ArgumentNullError(\"configParams\");\n    }\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n  static extractHeaderValue(headerKey, headers) {\n    let headerValue = \"\";\n    try {\n      const arr = headers.trim().split(/[\\r\\n]+/);\n      const headerMap = {};\n      arr.forEach(line => {\n        const parts = line.split(\": \");\n        const header = parts.shift().toLowerCase();\n        const value = parts.join(\": \");\n        headerMap[header] = value;\n      });\n      headerValue = headerMap[headerKey.toLowerCase()];\n    } catch (e) {\n      // ignore the error\n    }\n    return headerValue;\n  }\n  set options(configParams) {\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n  setHeaders(key, value) {\n    this.privHeaders[key] = value;\n  }\n  request(method, uri) {\n    let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let body = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let binaryBody = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    const responseReceivedDeferral = new Deferred();\n    const requestCommand = method === RestRequestType.File ? \"POST\" : method;\n    const handleRestResponse = function (data) {\n      let j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const d = data;\n      return {\n        data: JSON.stringify(j),\n        headers: JSON.stringify(data.headers),\n        json: j,\n        ok: data.statusCode >= 200 && data.statusCode < 300,\n        status: data.statusCode,\n        statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\n      };\n    };\n    const blobToArrayBuffer = blob => {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      return new Promise(resolve => {\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n      });\n    };\n    const send = postData => {\n      const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\n      const params = this.queryParams(queryParams) === \"\" ? \"\" : `?${this.queryParams(queryParams)}`;\n      sendRequest(params, postData).then(data => __awaiter(this, void 0, void 0, function* () {\n        if (method === RestRequestType.Delete || data.statusCode === 204) {\n          // No JSON from Delete and reset (204) operations\n          responseReceivedDeferral.resolve(handleRestResponse(data));\n        } else {\n          try {\n            const j = yield data.json();\n            responseReceivedDeferral.resolve(handleRestResponse(data, j));\n          } catch (_a) {\n            responseReceivedDeferral.resolve(handleRestResponse(data));\n          }\n        }\n      })).catch(error => {\n        responseReceivedDeferral.reject(error);\n      });\n    };\n    if (this.privIgnoreCache) {\n      this.privHeaders[\"Cache-Control\"] = \"no-cache\";\n    }\n    if (method === RestRequestType.File && binaryBody) {\n      const contentType = \"multipart/form-data\";\n      this.privHeaders[\"content-type\"] = contentType;\n      this.privHeaders[\"Content-Type\"] = contentType;\n      if (typeof Blob !== \"undefined\" && binaryBody instanceof Blob) {\n        blobToArrayBuffer(binaryBody).then(res => {\n          send(res);\n        }).catch(error => {\n          responseReceivedDeferral.reject(error);\n        });\n      } else {\n        send(binaryBody);\n      }\n    } else {\n      if (method === RestRequestType.Post && body) {\n        this.privHeaders[\"content-type\"] = \"application/json\";\n        this.privHeaders[\"Content-Type\"] = \"application/json\";\n      }\n      send(body);\n    }\n    return responseReceivedDeferral.promise;\n  }\n  withQuery(url) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryString = this.queryParams(params);\n    return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n  }\n  queryParams() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Object.keys(params).map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k])).join(\"&\");\n  }\n}","map":{"version":3,"mappings":"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","names":["bent","ArgumentNullError","Deferred","RestRequestType","RestMessageAdapter","constructor","configParams","privHeaders","headers","privIgnoreCache","ignoreCache","extractHeaderValue","headerKey","headerValue","arr","trim","split","headerMap","forEach","line","parts","header","shift","toLowerCase","value","join","e","options","setHeaders","key","request","method","uri","queryParams","body","binaryBody","responseReceivedDeferral","requestCommand","File","handleRestResponse","data","j","d","JSON","stringify","json","ok","statusCode","status","statusText","error","message","statusMessage","blobToArrayBuffer","blob","reader","FileReader","readAsArrayBuffer","Promise","resolve","onloadend","result","send","postData","sendRequest","params","then","__awaiter","Delete","catch","reject","contentType","Blob","res","Post","promise","withQuery","url","queryString","indexOf","Object","keys","map","k","encodeURIComponent"],"sources":["src/common.browser/RestMessageAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport bent, { BentResponse, RequestBody } from \"bent\";\r\nimport {\r\n    ArgumentNullError,\r\n    Deferred\r\n} from \"../common/Exports\";\r\nimport { IRequestOptions } from \"./Exports\";\r\n\r\nexport enum RestRequestType {\r\n    Get = \"GET\",\r\n    Post = \"POST\",\r\n    Delete = \"DELETE\",\r\n    File = \"file\",\r\n}\r\n\r\nexport interface IRestResponse {\r\n    ok: boolean;\r\n    status: number;\r\n    statusText: string;\r\n    data: string;\r\n    json: any;\r\n    headers: string;\r\n}\r\n\r\ninterface JsonError {\r\n    error?: {\r\n        message: string;\r\n    };\r\n}\r\n\r\n// accept rest operations via request method and return abstracted objects from server response\r\nexport class RestMessageAdapter {\r\n\r\n    private privIgnoreCache: boolean;\r\n    private privHeaders: { [key: string]: string };\r\n\r\n    public constructor(\r\n        configParams: IRequestOptions\r\n        ) {\r\n\r\n        if (!configParams) {\r\n            throw new ArgumentNullError(\"configParams\");\r\n        }\r\n\r\n        this.privHeaders = configParams.headers;\r\n        this.privIgnoreCache = configParams.ignoreCache;\r\n    }\r\n\r\n    public static extractHeaderValue(headerKey: string, headers: string): string {\r\n        let headerValue: string = \"\";\r\n\r\n        try {\r\n            const arr = headers.trim().split(/[\\r\\n]+/);\r\n            const headerMap: { [key: string]: string } = {};\r\n            arr.forEach((line: string): void => {\r\n                const parts = line.split(\": \");\r\n                const header = parts.shift().toLowerCase();\r\n                const value = parts.join(\": \");\r\n                headerMap[header] = value;\r\n            });\r\n\r\n            headerValue = headerMap[headerKey.toLowerCase()];\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n\r\n        return headerValue;\r\n    }\r\n\r\n    public set options(configParams: IRequestOptions) {\r\n        this.privHeaders = configParams.headers;\r\n        this.privIgnoreCache = configParams.ignoreCache;\r\n    }\r\n\r\n    public setHeaders(key: string, value: string): void {\r\n        this.privHeaders[key] = value;\r\n    }\r\n\r\n    public request(\r\n        method: RestRequestType,\r\n        uri: string,\r\n        queryParams: { [key: string]: any } = {},\r\n        body: any = null,\r\n        binaryBody: Blob | Buffer = null,\r\n        ): Promise<IRestResponse> {\r\n\r\n        const responseReceivedDeferral = new Deferred<IRestResponse>();\r\n\r\n        const requestCommand = method === RestRequestType.File ? \"POST\" : method;\r\n        const handleRestResponse = (data: BentResponse, j: JsonError = {}): IRestResponse => {\r\n            const d: { statusText?: string; statusMessage?: string } = data;\r\n            return {\r\n                data: JSON.stringify(j),\r\n                headers: JSON.stringify(data.headers),\r\n                json: j,\r\n                ok: data.statusCode >= 200 && data.statusCode < 300,\r\n                status: data.statusCode,\r\n                statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\r\n            };\r\n        };\r\n\r\n        const blobToArrayBuffer = (blob: Blob): Promise<unknown> => {\r\n            const reader = new FileReader();\r\n            reader.readAsArrayBuffer(blob);\r\n            return new Promise((resolve: (value: unknown) => void): void => {\r\n                reader.onloadend = (): void => {\r\n                resolve(reader.result);\r\n                };\r\n            });\r\n        };\r\n\r\n        const send = (postData: RequestBody): void => {\r\n            const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\r\n            const params = this.queryParams(queryParams) === \"\" ? \"\" : `?${this.queryParams(queryParams)}`;\r\n            sendRequest(params, postData).then( async (data: BentResponse): Promise<void> => {\r\n                if (method === RestRequestType.Delete || data.statusCode === 204) {\r\n                    // No JSON from Delete and reset (204) operations\r\n                    responseReceivedDeferral.resolve(handleRestResponse(data));\r\n                } else {\r\n                    try {\r\n                        const j: JsonError = await data.json() as JsonError;\r\n                        responseReceivedDeferral.resolve(handleRestResponse(data, j));\r\n                    } catch {\r\n                        responseReceivedDeferral.resolve(handleRestResponse(data));\r\n                    }\r\n                }\r\n            }).catch((error: string): void => {\r\n                responseReceivedDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        if (this.privIgnoreCache) {\r\n            this.privHeaders[\"Cache-Control\"] = \"no-cache\";\r\n        }\r\n\r\n        if (method === RestRequestType.File && binaryBody) {\r\n            const contentType = \"multipart/form-data\";\r\n            this.privHeaders[\"content-type\"] = contentType;\r\n            this.privHeaders[\"Content-Type\"] = contentType;\r\n            if (typeof (Blob) !== \"undefined\" && binaryBody instanceof Blob) {\r\n                blobToArrayBuffer(binaryBody).then( (res: RequestBody): void => {\r\n                    send(res);\r\n                }).catch((error: any): void => {\r\n                    responseReceivedDeferral.reject(error as string);\r\n                });\r\n            } else {\r\n                send(binaryBody as Buffer);\r\n            }\r\n        } else {\r\n            if (method === RestRequestType.Post && body) {\r\n                this.privHeaders[\"content-type\"] = \"application/json\";\r\n                this.privHeaders[\"Content-Type\"] = \"application/json\";\r\n            }\r\n            send(body as RequestBody);\r\n        }\r\n        return responseReceivedDeferral.promise;\r\n    }\r\n\r\n    private withQuery(url: string, params: { [key: string]: string } = {}): any {\r\n        const queryString = this.queryParams(params);\r\n        return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\r\n    }\r\n\r\n    private queryParams(params: { [key: string]: string } = {}): string {\r\n        return Object.keys(params)\r\n            .map((k: string): string => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\r\n            .join(\"&\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}