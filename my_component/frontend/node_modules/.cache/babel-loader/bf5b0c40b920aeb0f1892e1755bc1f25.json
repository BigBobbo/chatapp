{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class ReplayableAudioNode {\n  constructor(audioSource, bytesPerSecond) {\n    this.privBuffers = [];\n    this.privReplayOffset = 0;\n    this.privLastShrinkOffset = 0;\n    this.privBufferStartOffset = 0;\n    this.privBufferSerial = 0;\n    this.privBufferedBytes = 0;\n    this.privReplay = false;\n    this.privLastChunkAcquiredTime = 0;\n    this.privAudioNode = audioSource;\n    this.privBytesPerSecond = bytesPerSecond;\n  }\n  id() {\n    return this.privAudioNode.id();\n  }\n  // Reads and returns the next chunk of audio buffer.\n  // If replay of existing buffers are needed, read() will first seek and replay\n  // existing content, and upoin completion it will read new content from the underlying\n  // audio node, saving that content into the replayable buffers.\n  read() {\n    // if there is a replay request to honor.\n    if (!!this.privReplay && this.privBuffers.length !== 0) {\n      // Find the start point in the buffers.\n      // Offsets are in 100ns increments.\n      // So how many bytes do we need to seek to get the right offset?\n      const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;\n      let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n      if (0 !== bytesToSeek % 2) {\n        bytesToSeek++;\n      }\n      let i = 0;\n      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n      }\n      if (i < this.privBuffers.length) {\n        const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\n        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7;\n        // If we've reached the end of the buffers, stop replaying.\n        if (i === this.privBuffers.length - 1) {\n          this.privReplay = false;\n        }\n        return Promise.resolve({\n          buffer: retVal,\n          isEnd: false,\n          timeReceived: this.privBuffers[i].chunk.timeReceived\n        });\n      }\n    }\n    return this.privAudioNode.read().then(result => {\n      if (result && result.buffer) {\n        this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\n        this.privBufferedBytes += result.buffer.byteLength;\n      }\n      return result;\n    });\n  }\n  detach() {\n    this.privBuffers = undefined;\n    return this.privAudioNode.detach();\n  }\n  replay() {\n    if (this.privBuffers && 0 !== this.privBuffers.length) {\n      this.privReplay = true;\n      this.privReplayOffset = this.privLastShrinkOffset;\n    }\n  }\n  // Shrinks the existing audio buffers to start at the new offset, or at the\n  // beginning of the buffer closest to the requested offset.\n  // A replay request will start from the last shrink point.\n  shrinkBuffers(offset) {\n    if (this.privBuffers === undefined || this.privBuffers.length === 0) {\n      return;\n    }\n    this.privLastShrinkOffset = offset;\n    // Find the start point in the buffers.\n    // Offsets are in 100ns increments.\n    // So how many bytes do we need to seek to get the right offset?\n    const offsetToSeek = offset - this.privBufferStartOffset;\n    let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n    let i = 0;\n    while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n      bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n    }\n    this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);\n    this.privBuffers = this.privBuffers.slice(i);\n  }\n  // Finds the time a buffer of audio was first seen by offset.\n  findTimeAtOffset(offset) {\n    if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\n      return 0;\n    }\n    for (const value of this.privBuffers) {\n      const startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;\n      const endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;\n      if (offset >= startOffset && offset <= endOffset) {\n        return value.chunk.timeReceived;\n      }\n    }\n    return 0;\n  }\n}\n// Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\nclass BufferEntry {\n  constructor(chunk, serial, byteOffset) {\n    this.chunk = chunk;\n    this.serial = serial;\n    this.byteOffset = byteOffset;\n  }\n}","map":{"version":3,"mappings":"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","names":["ReplayableAudioNode","constructor","audioSource","bytesPerSecond","privAudioNode","privBytesPerSecond","id","read","privReplay","privBuffers","length","offsetToSeek","privReplayOffset","privBufferStartOffset","bytesToSeek","Math","round","i","chunk","buffer","byteLength","retVal","slice","Promise","resolve","isEnd","timeReceived","then","result","push","BufferEntry","privBufferSerial","privBufferedBytes","detach","undefined","replay","privLastShrinkOffset","shrinkBuffers","offset","findTimeAtOffset","value","startOffset","byteOffset","endOffset","serial"],"sources":["src/common.browser/ReplayableAudioNode.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nimport {\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n} from \"../common/Exports\";\r\n\r\nexport class ReplayableAudioNode implements IAudioStreamNode {\r\n    private privAudioNode: IAudioStreamNode;\r\n    private privBytesPerSecond: number;\r\n    private privBuffers: BufferEntry[] = [];\r\n    private privReplayOffset: number = 0;\r\n    private privLastShrinkOffset: number = 0;\r\n    private privBufferStartOffset: number = 0;\r\n    private privBufferSerial: number = 0;\r\n    private privBufferedBytes: number = 0;\r\n    private privReplay: boolean = false;\r\n    private privLastChunkAcquiredTime: number = 0;\r\n\r\n    public constructor(audioSource: IAudioStreamNode, bytesPerSecond: number) {\r\n        this.privAudioNode = audioSource;\r\n        this.privBytesPerSecond = bytesPerSecond;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privAudioNode.id();\r\n    }\r\n\r\n    // Reads and returns the next chunk of audio buffer.\r\n    // If replay of existing buffers are needed, read() will first seek and replay\r\n    // existing content, and upoin completion it will read new content from the underlying\r\n    // audio node, saving that content into the replayable buffers.\r\n    public read(): Promise<IStreamChunk<ArrayBuffer>> {\r\n        // if there is a replay request to honor.\r\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\r\n            // Find the start point in the buffers.\r\n            // Offsets are in 100ns increments.\r\n            // So how many bytes do we need to seek to get the right offset?\r\n            const offsetToSeek: number = this.privReplayOffset - this.privBufferStartOffset;\r\n\r\n            let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n            if (0 !== (bytesToSeek % 2)) {\r\n                bytesToSeek++;\r\n            }\r\n\r\n            let i: number = 0;\r\n\r\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n                bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n            }\r\n\r\n            if (i < this.privBuffers.length) {\r\n                const retVal: ArrayBuffer = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\r\n\r\n                this.privReplayOffset += (retVal.byteLength / this.privBytesPerSecond) * 1e+7;\r\n\r\n                // If we've reached the end of the buffers, stop replaying.\r\n                if (i === this.privBuffers.length - 1) {\r\n                    this.privReplay = false;\r\n                }\r\n\r\n                return Promise.resolve<IStreamChunk<ArrayBuffer>>({\r\n                    buffer: retVal,\r\n                    isEnd: false,\r\n                    timeReceived: this.privBuffers[i].chunk.timeReceived,\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.privAudioNode.read()\r\n            .then((result: IStreamChunk<ArrayBuffer>): IStreamChunk<ArrayBuffer> => {\r\n                if (result && result.buffer) {\r\n                    this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\r\n                    this.privBufferedBytes += result.buffer.byteLength;\r\n                }\r\n                return result;\r\n            });\r\n    }\r\n\r\n    public detach(): Promise<void> {\r\n        this.privBuffers = undefined;\r\n        return this.privAudioNode.detach();\r\n    }\r\n\r\n    public replay(): void {\r\n        if (this.privBuffers && 0 !== this.privBuffers.length) {\r\n            this.privReplay = true;\r\n            this.privReplayOffset = this.privLastShrinkOffset;\r\n        }\r\n    }\r\n\r\n    // Shrinks the existing audio buffers to start at the new offset, or at the\r\n    // beginning of the buffer closest to the requested offset.\r\n    // A replay request will start from the last shrink point.\r\n    public shrinkBuffers(offset: number): void {\r\n        if (this.privBuffers === undefined || this.privBuffers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.privLastShrinkOffset = offset;\r\n\r\n        // Find the start point in the buffers.\r\n        // Offsets are in 100ns increments.\r\n        // So how many bytes do we need to seek to get the right offset?\r\n        const offsetToSeek: number = offset - this.privBufferStartOffset;\r\n\r\n        let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n\r\n        let i: number = 0;\r\n\r\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n            bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n        }\r\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privBytesPerSecond) * 1e+7));\r\n        this.privBuffers = this.privBuffers.slice(i);\r\n    }\r\n\r\n    // Finds the time a buffer of audio was first seen by offset.\r\n    public findTimeAtOffset(offset: number): number {\r\n        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        for (const value of this.privBuffers) {\r\n            const startOffset: number = (value.byteOffset / this.privBytesPerSecond) * 1e7;\r\n            const endOffset: number = startOffset + ((value.chunk.buffer.byteLength / this.privBytesPerSecond) * 1e7);\r\n\r\n            if (offset >= startOffset && offset <= endOffset) {\r\n                return value.chunk.timeReceived;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\n// Primary use of this class is to help debugging problems with the replay\r\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\r\n// the ArrayBuffer directly.\r\nclass BufferEntry {\r\n    public chunk: IStreamChunk<ArrayBuffer>;\r\n    public serial: number;\r\n    public byteOffset: number;\r\n\r\n    public constructor(chunk: IStreamChunk<ArrayBuffer>, serial: number, byteOffset: number) {\r\n        this.chunk = chunk;\r\n        this.serial = serial;\r\n        this.byteOffset = byteOffset;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}