{"ast":null,"code":"/* eslint-disable import/order */\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport * as tls from \"tls\";\nimport * as ocsp from \"../../external/ocsp/ocsp\";\nimport { Events, OCSPCacheEntryExpiredEvent, OCSPCacheEntryNeedsRefreshEvent, OCSPCacheFetchErrorEvent, OCSPCacheHitEvent, OCSPCacheMissEvent, OCSPCacheUpdateCompleteEvent, OCSPCacheUpdateNeededEvent, OCSPDiskCacheHitEvent, OCSPDiskCacheStoreEvent, OCSPMemoryCacheHitEvent, OCSPMemoryCacheStoreEvent, OCSPResponseRetrievedEvent, OCSPStapleReceivedEvent, OCSPVerificationFailedEvent } from \"../common/Exports\";\nimport Agent from \"agent-base\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport Cache from \"async-disk-cache\";\nimport HttpsProxyAgent from \"https-proxy-agent\";\nimport * as net from \"net\";\nimport { OCSPCacheUpdateErrorEvent } from \"../common/OCSPEvents\";\nexport class CertCheckAgent {\n  constructor(proxyInfo) {\n    if (!!proxyInfo) {\n      this.privProxyInfo = proxyInfo;\n    }\n    // Initialize this here to allow tests to set the env variable before the cache is constructed.\n    if (!CertCheckAgent.privDiskCache) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n      CertCheckAgent.privDiskCache = new Cache(\"microsoft-cognitiveservices-speech-sdk-cache\", {\n        supportBuffer: true,\n        location: typeof process !== \"undefined\" && !!process.env.SPEECH_OCSP_CACHE_ROOT ? process.env.SPEECH_OCSP_CACHE_ROOT : undefined\n      });\n    }\n  }\n  // Test hook to force the disk cache to be recreated.\n  static forceReinitDiskCache() {\n    CertCheckAgent.privDiskCache = undefined;\n    CertCheckAgent.privMemCache = {};\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  GetAgent(disableStapling) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const agent = new Agent.Agent(this.CreateConnection);\n    if (this.privProxyInfo !== undefined && this.privProxyInfo.HostName !== undefined && this.privProxyInfo.Port > 0) {\n      const proxyName = \"privProxyInfo\";\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      agent[proxyName] = this.privProxyInfo;\n    }\n    return agent;\n  }\n  static GetProxyAgent(proxyInfo) {\n    const httpProxyOptions = {\n      host: proxyInfo.HostName,\n      port: proxyInfo.Port\n    };\n    if (!!proxyInfo.UserName) {\n      httpProxyOptions.headers = {\n        \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === undefined ? \"\" : proxyInfo.Password}`).toString(\"base64\")\n      };\n    } else {\n      httpProxyOptions.headers = {};\n    }\n    httpProxyOptions.headers.requestOCSP = \"true\";\n    const httpProxyAgent = new HttpsProxyAgent(httpProxyOptions);\n    return httpProxyAgent;\n  }\n  static OCSPCheck(socketPromise, proxyInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ocspRequest;\n      let stapling;\n      let resolved = false;\n      const socket = yield socketPromise;\n      socket.cork();\n      const tlsSocket = socket;\n      return new Promise((resolve, reject) => {\n        socket.on(\"OCSPResponse\", data => {\n          if (!!data) {\n            this.onEvent(new OCSPStapleReceivedEvent());\n            stapling = data;\n          }\n        });\n        socket.on(\"error\", error => {\n          if (!resolved) {\n            resolved = true;\n            socket.destroy();\n            reject(error);\n          }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises, @typescript-eslint/explicit-function-return-type\n        tlsSocket.on(\"secure\", () => __awaiter(this, void 0, void 0, function* () {\n          const peer = tlsSocket.getPeerCertificate(true);\n          try {\n            const issuer = yield this.GetIssuer(peer);\n            // We always need a request to verify the response.\n            ocspRequest = ocsp.request.generate(peer.raw, issuer.raw);\n            // Do we have a result for this certificate in our memory cache?\n            const sig = ocspRequest.id.toString(\"hex\");\n            // Stapled response trumps cached response.\n            if (!stapling) {\n              const cacheEntry = yield CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);\n              stapling = cacheEntry;\n            }\n            yield this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo);\n            socket.uncork();\n            resolved = true;\n            resolve(socket);\n          } catch (e) {\n            socket.destroy();\n            resolved = true;\n            reject(e);\n          }\n        }));\n      });\n    });\n  }\n  static GetIssuer(peer) {\n    if (peer.issuerCertificate) {\n      return Promise.resolve(peer.issuerCertificate);\n    }\n    return new Promise((resolve, reject) => {\n      const ocspAgent = new ocsp.Agent({});\n      ocspAgent.fetchIssuer(peer, null, (error, value) => {\n        if (!!error) {\n          reject(error);\n          return;\n        }\n        resolve(value);\n      });\n    });\n  }\n  static GetResponseFromCache(signature, ocspRequest, proxyInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let cachedResponse = CertCheckAgent.privMemCache[signature];\n      if (!!cachedResponse) {\n        this.onEvent(new OCSPMemoryCacheHitEvent(signature));\n      }\n      // Do we have a result for this certificate on disk in %TMP%?\n      if (!cachedResponse) {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n          const diskCacheResponse = yield CertCheckAgent.privDiskCache.get(signature);\n          if (!!diskCacheResponse.isCached) {\n            CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature));\n            CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value);\n            cachedResponse = diskCacheResponse.value;\n          }\n        } catch (error) {\n          cachedResponse = null;\n        }\n      }\n      if (!cachedResponse) {\n        return cachedResponse;\n      }\n      try {\n        const cachedOcspResponse = ocsp.utils.parseResponse(cachedResponse);\n        const responseValue = cachedOcspResponse.value;\n        const tbsData = responseValue.tbsResponseData;\n        if (tbsData.responses.length < 1) {\n          this.onEvent(new OCSPCacheFetchErrorEvent(signature, \"Not enough data in cached response\"));\n          return;\n        }\n        const cachedStartTime = tbsData.responses[0].thisUpdate;\n        const cachedNextTime = tbsData.responses[0].nextUpdate;\n        if (cachedNextTime < Date.now() + this.testTimeOffset - 60000) {\n          // Cached entry has expired.\n          this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime));\n          cachedResponse = null;\n        } else {\n          // If we're within one day of the next update, or 50% of the way through the validity period,\n          // background an update to the cache.\n          const minUpdate = Math.min(24 * 60 * 60 * 1000, (cachedNextTime - cachedStartTime) / 2);\n          if (cachedNextTime - (Date.now() + this.testTimeOffset) < minUpdate) {\n            this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime));\n            this.UpdateCache(ocspRequest, proxyInfo).catch(error => {\n              // Well, not much we can do here.\n              this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));\n            });\n          } else {\n            this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));\n          }\n        }\n      } catch (error) {\n        this.onEvent(new OCSPCacheFetchErrorEvent(signature, error));\n        cachedResponse = null;\n      }\n      if (!cachedResponse) {\n        this.onEvent(new OCSPCacheMissEvent(signature));\n      }\n      return cachedResponse;\n    });\n  }\n  static VerifyOCSPResponse(cacheValue, ocspRequest, proxyInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ocspResponse = cacheValue;\n      // Do we have a valid response?\n      if (!ocspResponse) {\n        ocspResponse = yield CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo);\n      }\n      return new Promise((resolve, reject) => {\n        ocsp.verify({\n          request: ocspRequest,\n          response: ocspResponse\n        }, error => {\n          if (!!error) {\n            CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString(\"hex\"), error));\n            // Bad Cached Value? One more try without the cache.\n            if (!!cacheValue) {\n              this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then(() => {\n                resolve();\n              }, error => {\n                reject(error);\n              });\n            } else {\n              reject(error);\n            }\n          } else {\n            if (!cacheValue) {\n              CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString(\"hex\"), ocspResponse);\n            }\n            resolve();\n          }\n        });\n      });\n    });\n  }\n  static UpdateCache(req, proxyInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signature = req.id.toString(\"hex\");\n      this.onEvent(new OCSPCacheUpdateNeededEvent(signature));\n      const rawResponse = yield this.GetOCSPResponse(req, proxyInfo);\n      this.StoreCacheEntry(signature, rawResponse);\n      this.onEvent(new OCSPCacheUpdateCompleteEvent(req.id.toString(\"hex\")));\n    });\n  }\n  static StoreCacheEntry(sig, rawResponse) {\n    this.StoreMemoryCacheEntry(sig, rawResponse);\n    this.StoreDiskCacheEntry(sig, rawResponse);\n  }\n  static StoreMemoryCacheEntry(sig, rawResponse) {\n    this.privMemCache[sig] = rawResponse;\n    this.onEvent(new OCSPMemoryCacheStoreEvent(sig));\n  }\n  static StoreDiskCacheEntry(sig, rawResponse) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    this.privDiskCache.set(sig, rawResponse).then(() => {\n      this.onEvent(new OCSPDiskCacheStoreEvent(sig));\n    });\n  }\n  static GetOCSPResponse(req, proxyInfo) {\n    const ocspMethod = \"1.3.6.1.5.5.7.48.1\";\n    let options = {};\n    if (!!proxyInfo) {\n      const agent = CertCheckAgent.GetProxyAgent(proxyInfo);\n      options.agent = agent;\n    }\n    return new Promise((resolve, reject) => {\n      ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, (error, uri) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        const url = new URL(uri);\n        options = Object.assign(Object.assign({}, options), {\n          host: url.host,\n          protocol: url.protocol,\n          port: url.port,\n          path: url.pathname,\n          hostname: url.host\n        });\n        ocsp.utils.getResponse(options, req.data, (error, raw) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          const certID = req.certID;\n          this.onEvent(new OCSPResponseRetrievedEvent(certID.toString(\"hex\")));\n          resolve(raw);\n        });\n      });\n    });\n  }\n  static onEvent(event) {\n    Events.instance.onEvent(event);\n  }\n  CreateConnection(request, options) {\n    const enableOCSP = typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\" && options.secureEndpoint;\n    let socketPromise;\n    options = Object.assign(Object.assign({}, options), {\n      requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,\n      servername: options.host\n    });\n    if (!!this.privProxyInfo) {\n      const httpProxyAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);\n      const baseAgent = httpProxyAgent;\n      socketPromise = new Promise((resolve, reject) => {\n        baseAgent.callback(request, options, (error, socket) => {\n          if (!!error) {\n            reject(error);\n          } else {\n            resolve(socket);\n          }\n        });\n      });\n    } else {\n      if (!!options.secureEndpoint) {\n        socketPromise = Promise.resolve(tls.connect(options));\n      } else {\n        socketPromise = Promise.resolve(net.connect(options));\n      }\n    }\n    if (!!enableOCSP) {\n      return CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo);\n    } else {\n      return socketPromise;\n    }\n  }\n}\n// Test hook to enable forcing expiration / refresh to happen.\nCertCheckAgent.testTimeOffset = 0;\n// Test hook to disable stapling for cache testing.\nCertCheckAgent.forceDisableOCSPStapling = false;\n// An in memory cache for recived responses.\nCertCheckAgent.privMemCache = {};","map":{"version":3,"mappings":"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","names":["tls","ocsp","Events","OCSPCacheEntryExpiredEvent","OCSPCacheEntryNeedsRefreshEvent","OCSPCacheFetchErrorEvent","OCSPCacheHitEvent","OCSPCacheMissEvent","OCSPCacheUpdateCompleteEvent","OCSPCacheUpdateNeededEvent","OCSPDiskCacheHitEvent","OCSPDiskCacheStoreEvent","OCSPMemoryCacheHitEvent","OCSPMemoryCacheStoreEvent","OCSPResponseRetrievedEvent","OCSPStapleReceivedEvent","OCSPVerificationFailedEvent","Agent","Cache","HttpsProxyAgent","net","OCSPCacheUpdateErrorEvent","CertCheckAgent","constructor","proxyInfo","privProxyInfo","privDiskCache","supportBuffer","location","process","env","SPEECH_OCSP_CACHE_ROOT","undefined","forceReinitDiskCache","privMemCache","GetAgent","disableStapling","agent","CreateConnection","HostName","Port","proxyName","GetProxyAgent","httpProxyOptions","host","port","UserName","headers","Buffer","Password","toString","requestOCSP","httpProxyAgent","OCSPCheck","socketPromise","ocspRequest","stapling","resolved","socket","cork","tlsSocket","Promise","resolve","reject","on","data","onEvent","error","destroy","__awaiter","peer","getPeerCertificate","issuer","GetIssuer","request","generate","raw","sig","id","cacheEntry","GetResponseFromCache","VerifyOCSPResponse","uncork","e","issuerCertificate","ocspAgent","fetchIssuer","value","signature","cachedResponse","diskCacheResponse","get","isCached","StoreMemoryCacheEntry","cachedOcspResponse","utils","parseResponse","responseValue","tbsData","tbsResponseData","responses","length","cachedStartTime","thisUpdate","cachedNextTime","nextUpdate","Date","now","testTimeOffset","minUpdate","Math","min","UpdateCache","catch","cacheValue","ocspResponse","GetOCSPResponse","verify","response","then","StoreCacheEntry","req","rawResponse","StoreDiskCacheEntry","set","ocspMethod","options","getAuthorityInfo","cert","uri","url","URL","protocol","path","pathname","hostname","getResponse","certID","event","instance","enableOCSP","NODE_TLS_REJECT_UNAUTHORIZED","SPEECH_CONDUCT_OCSP_CHECK","secureEndpoint","forceDisableOCSPStapling","servername","baseAgent","callback","connect"],"sources":["src/common.browser/CertChecks.ts"],"sourcesContent":["/* eslint-disable import/order */\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport * as http from \"http\";\r\nimport * as tls from \"tls\";\r\nimport * as ocsp from \"../../external/ocsp/ocsp\";\r\nimport {\r\n    Events,\r\n    OCSPCacheEntryExpiredEvent,\r\n    OCSPCacheEntryNeedsRefreshEvent,\r\n    OCSPCacheFetchErrorEvent,\r\n    OCSPCacheHitEvent,\r\n    OCSPCacheMissEvent,\r\n    OCSPCacheUpdateCompleteEvent,\r\n    OCSPCacheUpdateNeededEvent,\r\n    OCSPDiskCacheHitEvent,\r\n    OCSPDiskCacheStoreEvent,\r\n    OCSPEvent,\r\n    OCSPMemoryCacheHitEvent,\r\n    OCSPMemoryCacheStoreEvent,\r\n    OCSPResponseRetrievedEvent,\r\n    OCSPStapleReceivedEvent,\r\n    OCSPVerificationFailedEvent,\r\n} from \"../common/Exports\";\r\nimport { IStringDictionary } from \"../common/IDictionary\";\r\nimport { ProxyInfo } from \"./ProxyInfo\";\r\n\r\nimport Agent from \"agent-base\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n// @ts-ignore\r\nimport Cache from \"async-disk-cache\";\r\nimport HttpsProxyAgent from \"https-proxy-agent\";\r\nimport * as net from \"net\";\r\nimport { OCSPCacheUpdateErrorEvent } from \"../common/OCSPEvents\";\r\n\r\n\r\ninterface tbsUpdateResponse {\r\n    thisUpdate: number;\r\n    nextUpdate: number;\r\n}\r\n\r\ninterface tbsResponse {\r\n    tbsResponseData: {\r\n        responses: tbsUpdateResponse[];\r\n    };\r\n}\r\n\r\nexport class CertCheckAgent {\r\n\r\n    // Test hook to enable forcing expiration / refresh to happen.\r\n    public static testTimeOffset: number = 0;\r\n\r\n    // Test hook to disable stapling for cache testing.\r\n    public static forceDisableOCSPStapling: boolean = false;\r\n\r\n    // An in memory cache for recived responses.\r\n    private static privMemCache: IStringDictionary<Buffer> = {};\r\n\r\n    // The on disk cache.\r\n    private static privDiskCache: Cache;\r\n\r\n    private privProxyInfo: ProxyInfo;\r\n\r\n    public constructor(proxyInfo?: ProxyInfo) {\r\n        if (!!proxyInfo) {\r\n            this.privProxyInfo = proxyInfo;\r\n        }\r\n\r\n        // Initialize this here to allow tests to set the env variable before the cache is constructed.\r\n        if (!CertCheckAgent.privDiskCache) {\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\r\n            CertCheckAgent.privDiskCache = new Cache(\"microsoft-cognitiveservices-speech-sdk-cache\", { supportBuffer: true, location: (typeof process !== \"undefined\" && !!process.env.SPEECH_OCSP_CACHE_ROOT) ? process.env.SPEECH_OCSP_CACHE_ROOT : undefined });\r\n        }\r\n    }\r\n\r\n    // Test hook to force the disk cache to be recreated.\r\n    public static forceReinitDiskCache(): void {\r\n        CertCheckAgent.privDiskCache = undefined;\r\n        CertCheckAgent.privMemCache = {};\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public GetAgent(disableStapling?: boolean): http.Agent {\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        const agent: any = new Agent.Agent(this.CreateConnection);\r\n\r\n        if (this.privProxyInfo !== undefined &&\r\n            this.privProxyInfo.HostName !== undefined &&\r\n            this.privProxyInfo.Port > 0) {\r\n            const proxyName: string = \"privProxyInfo\";\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n            agent[proxyName] = this.privProxyInfo;\r\n        }\r\n\r\n        return agent as http.Agent;\r\n    }\r\n\r\n    private static GetProxyAgent(proxyInfo: ProxyInfo): HttpsProxyAgent {\r\n        const httpProxyOptions: HttpsProxyAgent.HttpsProxyAgentOptions = {\r\n            host: proxyInfo.HostName,\r\n            port: proxyInfo.Port,\r\n        };\r\n\r\n        if (!!proxyInfo.UserName) {\r\n            httpProxyOptions.headers = {\r\n                \"Proxy-Authentication\": \"Basic \" + new Buffer(`${proxyInfo.UserName}:${(proxyInfo.Password === undefined) ? \"\" : proxyInfo.Password}`).toString(\"base64\"),\r\n            };\r\n        } else {\r\n            httpProxyOptions.headers = {};\r\n        }\r\n\r\n        httpProxyOptions.headers.requestOCSP = \"true\";\r\n\r\n        const httpProxyAgent: HttpsProxyAgent = new HttpsProxyAgent(httpProxyOptions);\r\n        return httpProxyAgent;\r\n    }\r\n\r\n    private static async OCSPCheck(socketPromise: Promise<net.Socket>, proxyInfo: ProxyInfo): Promise<net.Socket> {\r\n        let ocspRequest: ocsp.Request;\r\n        let stapling: Buffer;\r\n        let resolved: boolean = false;\r\n\r\n        const socket: net.Socket = await socketPromise;\r\n        socket.cork();\r\n\r\n        const tlsSocket: tls.TLSSocket = socket as tls.TLSSocket;\r\n\r\n        return new Promise<net.Socket>((resolve: (value: net.Socket) => void, reject: (error: string | Error) => void): void => {\r\n            socket.on(\"OCSPResponse\", (data: Buffer): void => {\r\n                if (!!data) {\r\n                    this.onEvent(new OCSPStapleReceivedEvent());\r\n                    stapling = data;\r\n                }\r\n            });\r\n\r\n            socket.on(\"error\", (error: Error): void => {\r\n                if (!resolved) {\r\n                    resolved = true;\r\n                    socket.destroy();\r\n                    reject(error);\r\n                }\r\n            });\r\n\r\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises, @typescript-eslint/explicit-function-return-type\r\n            tlsSocket.on(\"secure\", async () => {\r\n                const peer: tls.DetailedPeerCertificate = tlsSocket.getPeerCertificate(true);\r\n                try {\r\n                    const issuer: tls.DetailedPeerCertificate = await this.GetIssuer(peer);\r\n\r\n                    // We always need a request to verify the response.\r\n                    ocspRequest = ocsp.request.generate(peer.raw, issuer.raw);\r\n\r\n                    // Do we have a result for this certificate in our memory cache?\r\n                    const sig: string = ocspRequest.id.toString(\"hex\");\r\n\r\n                    // Stapled response trumps cached response.\r\n                    if (!stapling) {\r\n                        const cacheEntry: Buffer = await CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);\r\n                        stapling = cacheEntry;\r\n                    }\r\n\r\n                    await this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo);\r\n\r\n                    socket.uncork();\r\n                    resolved = true;\r\n                    resolve(socket);\r\n                } catch (e) {\r\n                    socket.destroy();\r\n                    resolved = true;\r\n                    reject(e as string);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private static GetIssuer(peer: tls.DetailedPeerCertificate): Promise<tls.DetailedPeerCertificate> {\r\n        if (peer.issuerCertificate) {\r\n            return Promise.resolve(peer.issuerCertificate);\r\n        }\r\n\r\n        return new Promise<tls.DetailedPeerCertificate>((resolve: (value: tls.DetailedPeerCertificate) => void, reject: (reason: string) => void): void => {\r\n            const ocspAgent: ocsp.Agent = new ocsp.Agent({});\r\n            ocspAgent.fetchIssuer(peer, null, (error: string, value: tls.DetailedPeerCertificate): void => {\r\n                if (!!error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                resolve(value);\r\n            });\r\n        });\r\n    }\r\n\r\n    private static async GetResponseFromCache(signature: string, ocspRequest: ocsp.Request, proxyInfo: ProxyInfo): Promise<Buffer> {\r\n        let cachedResponse: Buffer = CertCheckAgent.privMemCache[signature];\r\n\r\n        if (!!cachedResponse) {\r\n            this.onEvent(new OCSPMemoryCacheHitEvent(signature));\r\n        }\r\n\r\n        // Do we have a result for this certificate on disk in %TMP%?\r\n        if (!cachedResponse) {\r\n            try {\r\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\r\n                const diskCacheResponse: { value: Buffer; isCached?: any } = await CertCheckAgent.privDiskCache.get(signature) as { value: Buffer; isCached?: any };\r\n                if (!!diskCacheResponse.isCached) {\r\n                    CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature));\r\n                    CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value);\r\n                    cachedResponse = diskCacheResponse.value;\r\n                }\r\n            } catch (error) {\r\n                cachedResponse = null;\r\n            }\r\n        }\r\n\r\n        if (!cachedResponse) {\r\n            return cachedResponse;\r\n        }\r\n\r\n        try {\r\n            const cachedOcspResponse: ocsp.Response = ocsp.utils.parseResponse(cachedResponse);\r\n            const responseValue: tbsResponse = cachedOcspResponse.value as tbsResponse;\r\n            const tbsData: { responses: tbsUpdateResponse[] } = responseValue.tbsResponseData;\r\n            if (tbsData.responses.length < 1) {\r\n                this.onEvent(new OCSPCacheFetchErrorEvent(signature, \"Not enough data in cached response\"));\r\n                return;\r\n            }\r\n\r\n            const cachedStartTime: number = tbsData.responses[0].thisUpdate;\r\n            const cachedNextTime: number = tbsData.responses[0].nextUpdate;\r\n\r\n            if (cachedNextTime < (Date.now() + this.testTimeOffset - 60000)) {\r\n                // Cached entry has expired.\r\n                this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime));\r\n                cachedResponse = null;\r\n            } else {\r\n                // If we're within one day of the next update, or 50% of the way through the validity period,\r\n                // background an update to the cache.\r\n\r\n                const minUpdate: number = Math.min(24 * 60 * 60 * 1000, (cachedNextTime - cachedStartTime) / 2);\r\n\r\n                if ((cachedNextTime - (Date.now() + this.testTimeOffset)) < minUpdate) {\r\n                    this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime));\r\n                    this.UpdateCache(ocspRequest, proxyInfo).catch((error: string): void => {\r\n                        // Well, not much we can do here.\r\n                        this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));\r\n                    });\r\n                } else {\r\n                    this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));\r\n                }\r\n            }\r\n        } catch (error) {\r\n            this.onEvent(new OCSPCacheFetchErrorEvent(signature, error as string));\r\n            cachedResponse = null;\r\n        }\r\n        if (!cachedResponse) {\r\n            this.onEvent(new OCSPCacheMissEvent(signature));\r\n        }\r\n        return cachedResponse;\r\n    }\r\n\r\n    private static async VerifyOCSPResponse(cacheValue: Buffer, ocspRequest: ocsp.Request, proxyInfo: ProxyInfo): Promise<void> {\r\n        let ocspResponse: Buffer = cacheValue;\r\n\r\n        // Do we have a valid response?\r\n        if (!ocspResponse) {\r\n            ocspResponse = await CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo);\r\n        }\r\n\r\n        return new Promise<void>((resolve: () => void, reject: (error: string | Error) => void): void => {\r\n            ocsp.verify({ request: ocspRequest, response: ocspResponse }, (error: string): void => {\r\n                if (!!error) {\r\n                    CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString(\"hex\"), error));\r\n\r\n                    // Bad Cached Value? One more try without the cache.\r\n                    if (!!cacheValue) {\r\n                        this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then((): void => {\r\n                            resolve();\r\n                        }, (error: Error): void => {\r\n                            reject(error);\r\n                        });\r\n                    } else {\r\n                        reject(error);\r\n                    }\r\n                } else {\r\n                    if (!cacheValue) {\r\n                        CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString(\"hex\"), ocspResponse);\r\n                    }\r\n                    resolve();\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private static async UpdateCache(req: ocsp.Request, proxyInfo: ProxyInfo): Promise<void> {\r\n        const signature: string = req.id.toString(\"hex\");\r\n        this.onEvent(new OCSPCacheUpdateNeededEvent(signature));\r\n\r\n        const rawResponse: Buffer = await this.GetOCSPResponse(req, proxyInfo);\r\n        this.StoreCacheEntry(signature, rawResponse);\r\n        this.onEvent(new OCSPCacheUpdateCompleteEvent(req.id.toString(\"hex\")));\r\n\r\n    }\r\n\r\n    private static StoreCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        this.StoreMemoryCacheEntry(sig, rawResponse);\r\n        this.StoreDiskCacheEntry(sig, rawResponse);\r\n    }\r\n\r\n    private static StoreMemoryCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        this.privMemCache[sig] = rawResponse;\r\n        this.onEvent(new OCSPMemoryCacheStoreEvent(sig));\r\n    }\r\n\r\n    private static StoreDiskCacheEntry(sig: string, rawResponse: Buffer): void {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\r\n        this.privDiskCache.set(sig, rawResponse).then((): void => {\r\n            this.onEvent(new OCSPDiskCacheStoreEvent(sig));\r\n        });\r\n    }\r\n\r\n    private static GetOCSPResponse(req: ocsp.Request, proxyInfo: ProxyInfo): Promise<Buffer> {\r\n\r\n        const ocspMethod: string = \"1.3.6.1.5.5.7.48.1\";\r\n        let options: http.RequestOptions = {};\r\n\r\n        if (!!proxyInfo) {\r\n            const agent: HttpsProxyAgent = CertCheckAgent.GetProxyAgent(proxyInfo);\r\n            options.agent = agent;\r\n        }\r\n\r\n        return new Promise<Buffer>((resolve: (value: Buffer) => void, reject: (error: string | Error) => void): void => {\r\n            ocsp.utils.getAuthorityInfo(req.cert as tls.DetailedPeerCertificate, ocspMethod, (error: string, uri: string): void => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                const url = new URL(uri);\r\n                options = { ...options, host: url.host, protocol: url.protocol, port: url.port, path: url.pathname, hostname: url.host };\r\n\r\n                ocsp.utils.getResponse(options, req.data, (error: string, raw: Buffer): void => {\r\n                    if (error) {\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n\r\n                    const certID: Buffer = req.certID as Buffer;\r\n                    this.onEvent(new OCSPResponseRetrievedEvent(certID.toString(\"hex\")));\r\n                    resolve(raw);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private static onEvent(event: OCSPEvent): void {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private CreateConnection(request: Agent.ClientRequest, options: Agent.RequestOptions): Promise<net.Socket> {\r\n        const enableOCSP: boolean = (typeof process !== \"undefined\" && process.env.NODE_TLS_REJECT_UNAUTHORIZED !== \"0\" && process.env.SPEECH_CONDUCT_OCSP_CHECK !== \"0\") && options.secureEndpoint;\r\n        let socketPromise: Promise<net.Socket>;\r\n\r\n        options = {\r\n            ...options,\r\n            ...{\r\n                requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,\r\n                servername: options.host\r\n            }\r\n        };\r\n\r\n        if (!!this.privProxyInfo) {\r\n            const httpProxyAgent: HttpsProxyAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);\r\n            const baseAgent: Agent.Agent = httpProxyAgent as unknown as Agent.Agent;\r\n\r\n            socketPromise = new Promise<net.Socket>((resolve: (value: net.Socket) => void, reject: (error: string | Error) => void): void => {\r\n                baseAgent.callback(request, options, (error: Error, socket: net.Socket): void => {\r\n                    if (!!error) {\r\n                        reject(error);\r\n                    } else {\r\n                        resolve(socket);\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            if (!!options.secureEndpoint) {\r\n                socketPromise = Promise.resolve(tls.connect(options));\r\n            } else {\r\n                socketPromise = Promise.resolve(net.connect(options));\r\n            }\r\n        }\r\n\r\n        if (!!enableOCSP) {\r\n            return CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo);\r\n        } else {\r\n            return socketPromise;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}