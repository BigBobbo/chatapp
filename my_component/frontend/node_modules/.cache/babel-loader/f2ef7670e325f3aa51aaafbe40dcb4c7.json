{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\nimport { BackgroundEvent, createGuid, createNoDashGuid, Deferred, Events, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport { ActivityReceivedEventArgs, CancellationErrorCode, CancellationReason, DialogServiceConfig, PropertyCollection, PropertyId, RecognitionEventArgs, ResultReason, SessionEventArgs, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, TurnStatusReceivedEventArgs } from \"../sdk/Exports\";\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechDetected, SpeechHypothesis, SpeechKeyword } from \"./Exports\";\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\n    this.privEvents = new EventSource();\n    this.privDialogServiceConnector = dialogServiceConnector;\n    this.receiveMessageOverride = () => this.receiveDialogMessageOverride();\n    this.privTurnStateManager = new DialogServiceTurnStateManager();\n    this.recognizeOverride = (recoMode, successCallback, errorCallback) => this.listenOnce(recoMode, successCallback, errorCallback);\n    this.postConnectImplOverride = connection => this.dialogConnectImpl(connection);\n    this.configConnectionOverride = connection => this.configConnection(connection);\n    this.disconnectOverride = () => this.privDisconnect();\n    this.privDialogAudioSource = audioSource;\n    this.agentConfigSent = false;\n    this.privLastResult = null;\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        this.terminateMessageLoop = true;\n      }\n    });\n  }\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const interactionGuid = createGuid();\n      const requestId = createNoDashGuid();\n      const agentMessage = {\n        context: {\n          interactionId: interactionGuid\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        messagePayload: JSON.parse(message),\n        version: 0.5\n      };\n      const agentMessageJson = JSON.stringify(agentMessage);\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n    });\n  }\n  privDisconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n      this.terminateMessageLoop = true;\n      this.agentConfigSent = false;\n      return;\n    });\n  }\n  processTypeSpecificMessages(connectionMessage) {\n    const resultProps = new PropertyCollection();\n    if (connectionMessage.messageType === MessageType.Text) {\n      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n    }\n    let result;\n    let processed;\n    switch (connectionMessage.path.toLowerCase()) {\n      case \"speech.phrase\":\n        const speechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n        if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\n          const args = this.fireEventForResult(speechPhrase, resultProps);\n          this.privLastResult = args.result;\n          if (!!this.privDialogServiceConnector.recognized) {\n            try {\n              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n              /* eslint-disable no-empty */\n            } catch (error) {\n              // Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.hypothesis\":\n        const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n        const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n        this.privRequestSession.onHypothesis(offset);\n        const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n        if (!!this.privDialogServiceConnector.recognizing) {\n          try {\n            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"speech.keyword\":\n        const keyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\n        result = new SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n        if (keyword.Status !== \"Accepted\") {\n          this.privLastResult = result;\n        }\n        const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n        if (!!this.privDialogServiceConnector.recognized) {\n          try {\n            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\n            /* eslint-disable no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"audio\":\n        {\n          const audioRequestId = connectionMessage.requestId.toUpperCase();\n          const turn = this.privTurnStateManager.GetTurn(audioRequestId);\n          try {\n            // Empty binary message signals end of stream.\n            if (!connectionMessage.binaryBody) {\n              turn.endAudioStream();\n            } else {\n              turn.audioStream.write(connectionMessage.binaryBody);\n            }\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        processed = true;\n        break;\n      case \"response\":\n        {\n          this.handleResponseMessage(connectionMessage);\n        }\n        processed = true;\n        break;\n      default:\n        break;\n    }\n    const defferal = new Deferred();\n    defferal.resolve(processed);\n    return defferal.promise;\n  }\n  // Cancels recognition.\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = true;\n      if (!!this.privRequestSession.isRecognizing) {\n        yield this.privRequestSession.onStopRecognizing();\n      }\n      if (!!this.privDialogServiceConnector.canceled) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n        try {\n          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n          /* eslint-disable no-empty */\n        } catch (_a) {}\n        if (!!this.privSuccessCallback) {\n          const result = new SpeechRecognitionResult(undefined,\n          // ResultId\n          ResultReason.Canceled, undefined,\n          // Text\n          undefined,\n          // Duration\n          undefined,\n          // Offset\n          undefined,\n          // Language\n          undefined,\n          // Language Detection Confidence\n          undefined,\n          // Speaker Id\n          error, undefined,\n          // Json\n          properties);\n          try {\n            this.privSuccessCallback(result);\n            this.privSuccessCallback = undefined;\n            /* eslint-disable no-empty */\n          } catch (_b) {}\n        }\n      }\n    });\n  }\n  listenOnce(recoMode, successCallback, errorCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privRecognizerConfig.recognitionMode = recoMode;\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallback;\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n      // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages();\n      const node = yield this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privDialogAudioSource.format;\n      const deviceInfo = yield this.privDialogAudioSource.deviceInfo;\n      const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n        return Promise.resolve();\n      }\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n      const audioSendPromise = this.sendAudio(audioNode);\n      // /* eslint-disable no-empty */\n      audioSendPromise.then(() => {}, error => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }));\n    });\n  }\n  // Establishes a websocket connection to the end point.\n  dialogConnectImpl(connection) {\n    this.privConnectionLoop = this.startMessageLoop();\n    return connection;\n  }\n  receiveDialogMessageOverride() {\n    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n    const communicationCustodian = new Deferred();\n    const loop = () => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const isDisposed = this.isDisposed();\n        const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n        if (isDisposed || terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve(undefined);\n          return;\n        }\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n        if (!message) {\n          return loop();\n        }\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n        switch (connectionMessage.path.toLowerCase()) {\n          case \"turn.start\":\n            {\n              const turnRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n              // turn started by the service\n              if (turnRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.StartTurn(turnRequestId);\n              } else {\n                this.privRequestSession.onServiceTurnStartResponse();\n              }\n            }\n            break;\n          case \"speech.startdetected\":\n            const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.speechStartDetected) {\n              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n            }\n            break;\n          case \"speech.enddetected\":\n            let json;\n            if (connectionMessage.textBody.length > 0) {\n              json = connectionMessage.textBody;\n            } else {\n              // If the request was empty, the JSON returned is empty.\n              json = \"{ Offset: 0 }\";\n            }\n            const speechStopDetected = SpeechDetected.fromJSON(json);\n            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n            if (!!this.privRecognizer.speechEndDetected) {\n              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n            }\n            break;\n          case \"turn.end\":\n            {\n              const turnEndRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n              // turn started by the service\n              if (turnEndRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n              } else {\n                // Audio session turn\n                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                yield this.privRequestSession.onServiceTurnEndResponse(false);\n                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                  if (!!this.privRecognizer.sessionStopped) {\n                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                  }\n                }\n                // report result to promise.\n                if (!!this.privSuccessCallback && this.privLastResult) {\n                  try {\n                    this.privSuccessCallback(this.privLastResult);\n                    this.privLastResult = null;\n                  } catch (e) {\n                    if (!!this.privErrorCallback) {\n                      this.privErrorCallback(e);\n                    }\n                  }\n                  // Only invoke the call back once.\n                  // and if it's successful don't invoke the\n                  // error after that.\n                  this.privSuccessCallback = undefined;\n                  this.privErrorCallback = undefined;\n                }\n              }\n            }\n            break;\n          default:\n            try {\n              const processed = yield this.processTypeSpecificMessages(connectionMessage);\n              if (!processed) {\n                if (!!this.serviceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n            } catch (e) {\n              //\n            }\n        }\n        const ret = loop();\n        return ret;\n      } catch (error) {\n        this.terminateMessageLoop = true;\n        communicationCustodian.resolve();\n      }\n    });\n    loop().catch(reason => {\n      Events.instance.onEvent(new BackgroundEvent(reason));\n    });\n    return communicationCustodian.promise;\n  }\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = false;\n      try {\n        yield this.receiveDialogMessageOverride();\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }\n      return Promise.resolve();\n    });\n  }\n  // Takes an established websocket connection to the endpoint and sends speech configuration information.\n  configConnection(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.terminateMessageLoop) {\n        this.terminateMessageLoop = false;\n        return Promise.reject(\"Connection to service terminated.\");\n      }\n      yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n      yield this.sendAgentConfig(connection);\n      return connection;\n    });\n  }\n  sendPreAudioMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.addKeywordContextData();\n      yield this.sendSpeechContext(connection, true);\n      yield this.sendAgentContext(connection);\n      yield this.sendWaveHeader(connection);\n    });\n  }\n  sendAgentConfig(connection) {\n    if (this.agentConfig && !this.agentConfigSent) {\n      if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\n        const config = this.agentConfig.get();\n        config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n        this.agentConfig.set(config);\n      }\n      this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\n      const agentConfigJson = this.agentConfig.toJsonString();\n      // guard against sending this multiple times on one connection\n      this.agentConfigSent = true;\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n    }\n    return;\n  }\n  sendAgentContext(connection) {\n    const guid = createGuid();\n    const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n    const agentContext = {\n      channelData: \"\",\n      context: {\n        interactionId: guid\n      },\n      messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n      version: 0.5\n    };\n    const agentContextJson = JSON.stringify(agentContext);\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n  }\n  fireEventForResult(serviceResult, properties) {\n    const resultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n    const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n  handleResponseMessage(responseMessage) {\n    // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n    // event according to the message type that's specified.\n    const responsePayload = JSON.parse(responseMessage.textBody);\n    switch (responsePayload.messageType.toLowerCase()) {\n      case \"message\":\n        const responseRequestId = responseMessage.requestId.toUpperCase();\n        const activityPayload = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n        const turn = this.privTurnStateManager.GetTurn(responseRequestId);\n        // update the conversation Id\n        if (activityPayload.conversationId) {\n          const updateAgentConfig = this.agentConfig.get();\n          updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n          this.agentConfig.set(updateAgentConfig);\n        }\n        const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n        const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n        if (!!this.privDialogServiceConnector.activityReceived) {\n          try {\n            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        break;\n      case \"messagestatus\":\n        if (!!this.privDialogServiceConnector.turnStatusReceived) {\n          try {\n            this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new TurnStatusReceivedEventArgs(responseMessage.textBody));\n            /* eslint-disable-next-line no-empty */\n          } catch (error) {\n            // Not going to let errors in the event handler\n            // trip things up.\n          }\n        }\n        break;\n      default:\n        Events.instance.onEvent(new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\n        break;\n    }\n  }\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n  addKeywordContextData() {\n    const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n    if (keywordPropertyValue === undefined) {\n      return;\n    }\n    const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n    const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n    const keywords = keywordPropertyValue.split(\";\");\n    const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n    const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n    const keywordDefinitionArray = [];\n    for (let i = 0; i < keywords.length; i++) {\n      const definition = {};\n      definition.text = keywords[i];\n      if (i < keywordOffsets.length) {\n        definition.offset = Number(keywordOffsets[i]);\n      }\n      if (i < keywordDurations.length) {\n        definition.duration = Number(keywordDurations[i]);\n      }\n      keywordDefinitionArray.push(definition);\n    }\n    this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n    this.speechContext.setSection(\"keywordDetection\", [{\n      clientDetectedKeywords: keywordDefinitionArray,\n      onReject: {\n        action: \"EndOfTurn\"\n      },\n      type: \"startTrigger\"\n    }]);\n  }\n}","map":{"version":3,"mappings":"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","names":["ReplayableAudioNode","SendingAgentContextMessageEvent","BackgroundEvent","createGuid","createNoDashGuid","Deferred","Events","EventSource","MessageType","ServiceEvent","AudioOutputFormatImpl","ActivityReceivedEventArgs","CancellationErrorCode","CancellationReason","DialogServiceConfig","PropertyCollection","PropertyId","RecognitionEventArgs","ResultReason","SessionEventArgs","SpeechRecognitionCanceledEventArgs","SpeechRecognitionEventArgs","SpeechRecognitionResult","TurnStatusReceivedEventArgs","DialogServiceTurnStateManager","CancellationErrorCodePropertyName","EnumTranslation","RecognitionStatus","ServiceRecognizerBase","SimpleSpeechPhrase","SpeechDetected","SpeechHypothesis","SpeechKeyword","ActivityPayloadResponse","SpeechConnectionMessage","DialogServiceAdapter","constructor","authentication","connectionFactory","audioSource","recognizerConfig","dialogServiceConnector","privEvents","privDialogServiceConnector","receiveMessageOverride","receiveDialogMessageOverride","privTurnStateManager","recognizeOverride","recoMode","successCallback","errorCallback","listenOnce","postConnectImplOverride","connection","dialogConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privDialogAudioSource","agentConfigSent","privLastResult","connectionEvents","attach","connectionEvent","name","terminateMessageLoop","sendMessage","message","interactionGuid","requestId","agentMessage","context","interactionId","messagePayload","JSON","parse","version","agentMessageJson","stringify","fetchConnection","send","Text","cancelRecognition","privRequestSession","sessionId","Error","NoError","processTypeSpecificMessages","connectionMessage","resultProps","messageType","setProperty","SpeechServiceResponse_JsonResult","textBody","result","processed","path","toLowerCase","speechPhrase","fromJSON","onPhraseRecognized","currentTurnAudioOffset","Offset","Duration","TooManyRequests","args","fireEventForResult","recognized","error","hypothesis","offset","RecognizingSpeech","Language","LanguageDetectionConfidence","undefined","onHypothesis","ev","recognizing","keyword","Status","RecognizedKeyword","NoMatch","event","duration","resultId","audioRequestId","toUpperCase","turn","GetTurn","binaryBody","endAudioStream","audioStream","write","handleResponseMessage","defferal","resolve","promise","cancellationReason","errorCode","isRecognizing","onStopRecognizing","canceled","properties","cancelEvent","privSuccessCallback","Canceled","privRecognizerConfig","recognitionMode","privErrorCallback","startNewRecognition","listenForServiceTelemetry","events","parameters","Speech_SessionId","conPromise","connectImpl","preAudioPromise","sendPreAudioMessages","node","audioNodeId","format","deviceInfo","audioNode","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","ConnectionFailure","Promise","sessionStartEventArgs","privRecognizer","sessionStarted","audioSendPromise","sendAudio","then","__awaiter","RuntimeError","privConnectionLoop","startMessageLoop","communicationCustodian","loop","isDisposed","read","fromConnectionMessage","turnRequestId","audioSessionReqId","StartTurn","onServiceTurnStartResponse","speechStartDetected","speechStartEventArgs","json","length","speechStopDetected","onServiceRecognized","speechStopEventArgs","speechEndDetected","turnEndRequestId","CompleteTurn","sessionStopEventArgs","onServiceTurnEndResponse","isContinuousRecognition","isSpeechEnded","sessionStopped","e","serviceEvents","onEvent","ret","catch","reason","instance","reject","sendSpeechServiceConfig","serialize","sendAgentConfig","addKeywordContextData","sendSpeechContext","sendAgentContext","sendWaveHeader","agentConfig","getProperty","Conversation_DialogType","DialogTypes","CustomCommands","config","get","botInfo","commandsCulture","SpeechServiceConnection_RecoLanguage","set","agentConfigJson","toJsonString","guid","speechActivityTemplate","Conversation_Speech_Activity_Template","agentContext","channelData","agentContextJson","serviceResult","resultReason","implTranslateRecognitionResult","DisplayText","responseMessage","responsePayload","responseRequestId","activityPayload","conversationId","updateAgentConfig","pullAudioOutputStream","processActivityPayload","fromSpeechSynthesisOutputFormatString","SpeechServiceConnection_SynthOutputFormat","activity","activityReceived","turnStatusReceived","keywordPropertyValue","keywordOffsetPropertyValue","keywordDurationPropertyValue","keywords","split","keywordOffsets","keywordDurations","keywordDefinitionArray","i","definition","text","Number","push","speechContext","setSection","clientDetectedKeywords","onReject","action","type"],"sources":["src/common.speech/DialogServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n    SpeechKeyword,\r\n} from \"./Exports\";\r\nimport { IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = (): Promise<void> => this.receiveDialogMessageOverride();\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride =\r\n            (recoMode: RecognitionMode, successCallback: (e: SpeechRecognitionResult) => void, errorCallback: (e: string) => void): Promise<void> =>\r\n            this.listenOnce(recoMode, successCallback, errorCallback);\r\n        this.postConnectImplOverride = (connection: Promise<IConnection>): Promise<IConnection> => this.dialogConnectImpl(connection);\r\n        this.configConnectionOverride = (connection: IConnection): Promise<IConnection> => this.configConnection(connection);\r\n        this.disconnectOverride = (): Promise<void> => this.privDisconnect();\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* eslint-disable no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.keyword\":\r\n                const keyword: SpeechKeyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch,\r\n                    keyword.Text,\r\n                    keyword.Duration,\r\n                    keyword.Offset,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (keyword.Status !== \"Accepted\") {\r\n                    this.privLastResult = result;\r\n                }\r\n\r\n                const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognized) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\r\n                        /* eslint-disable no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        const defferal = new Deferred<boolean>();\r\n        defferal.resolve(processed);\r\n        return defferal.promise;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* eslint-disable no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error as string);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* eslint-disable no-empty */\r\n        audioSendPromise.then((): void => { /* add? return true;*/ }, async (error: string): Promise<void> => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e as string);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        try {\r\n                            const processed = await this.processTypeSpecificMessages(connectionMessage);\r\n                            if (!processed) {\r\n                                if (!!this.serviceEvents) {\r\n                                    this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                                }\r\n                            }\r\n                        } catch (e) {\r\n                            //\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error as string);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(\"Connection to service terminated.\");\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        this.addKeywordContextData();\r\n        await this.sendSpeechContext(connection, true);\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig(connection: IConnection): Promise<void> {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext(connection: IConnection): Promise<void> {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage(responseMessage: SpeechConnectionMessage): void {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload: { messageType: string } = JSON.parse(responseMessage.textBody) as { messageType: string };\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* eslint-disable-next-line no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private addKeywordContextData(): void {\r\n        const keywordPropertyValue: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\r\n        if (keywordPropertyValue === undefined) {\r\n            return;\r\n        }\r\n\r\n        const keywordOffsetPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\r\n        const keywordDurationPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\r\n\r\n        const keywords = keywordPropertyValue.split(\";\");\r\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\r\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\r\n\r\n        const keywordDefinitionArray = [];\r\n        for (let i = 0; i < keywords.length; i++) {\r\n            const definition: { [section: string]: any } = {};\r\n            definition.text = keywords[i];\r\n            if (i < keywordOffsets.length) {\r\n                definition.offset = Number(keywordOffsets[i]);\r\n            }\r\n            if (i < keywordDurations.length) {\r\n                definition.duration = Number(keywordDurations[i]);\r\n            }\r\n            keywordDefinitionArray.push(definition);\r\n        }\r\n\r\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\r\n        this.speechContext.setSection(\"keywordDetection\", [{\r\n            clientDetectedKeywords: keywordDefinitionArray,\r\n            onReject: { action: \"EndOfTurn\" },\r\n            type: \"startTrigger\"\r\n        }]);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}